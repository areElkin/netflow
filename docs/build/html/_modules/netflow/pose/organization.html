

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>netflow.pose.organization &#8212; netflow v0.0.dev Manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/netflow/pose/organization';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/NF_logo3.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../../_static/NF_logo3.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../building/index.html">
                        Installation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../overview/index.html">
                        User guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../tutorial/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../reference/index.html">
                        API reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../references.html">
                        References
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../building/index.html">
                        Installation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../overview/index.html">
                        User guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../tutorial/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../reference/index.html">
                        API reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../references.html">
                        References
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item"><nav class="sidebar-indices-items">
  <p class="sidebar-indices-items__title" role="heading" aria-level="1">Indices</p>
  <ul class="indices-link">
        <li class="toctree-l1">
          <a class="reference internal"
             href="../../../genindex.html"
             accesskey="I">General Index</a>
        </li>
        <li class="toctree-l1">
          <a class="reference internal" href="../../../py-modindex.html">Python Module Index</a>
        </li>
  </ul>
</nav></div>
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">netflow.pose.organization</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for netflow.pose.organization</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2017 F. Alexander Wolf, P. Angerer, Theis Lab</span>
<span class="c1"># Revisions copyright 2024 R. Elkin</span>
<span class="c1"># All rights reserved.</span>
<span class="c1"># This file contains code derived, either in part or in whole,</span>
<span class="c1"># from the Scanpy library, which is governed by the original</span>
<span class="c1"># &quot;BSD 3-Clause License&quot;.</span>
<span class="c1"># Please see the LICENSE file included as part of this package for</span>
<span class="c1"># more details.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">organization</span>
<span class="sd">============</span>

<span class="sd">**Description**</span>

<span class="sd">The purpose of This module is to construct the organization of the</span>
<span class="sd">schema from a distance matrix and a single (or multiple)</span>
<span class="sd">data point(s) designated as the source.</span>

<span class="sd">This is done by using the branch detection algorithm</span>
<span class="sd">from the diffusion pseudo-time (DPT) algorithm for reconstructing</span>
<span class="sd">developmental progression and differentiation of cells proposed</span>
<span class="sd">in [Haghverdi16]_ as implemented in scanpy.</span>

<span class="sd">**Acknowledgement**</span>

<span class="sd">A large portion of the code was taken from</span>
<span class="sd">scanpy.tools._dpt.py and code related to</span>
<span class="sd">the method :mod:`scanpy.tools._dpt.dpt`.</span>

<span class="sd">Some noted differences made in scanpy implementation :</span>

<span class="sd">  - Add smoothing when computing maximal correlation cutoff</span>
<span class="sd">  - Include points not identified with any branch after split in the trunk (nonunique).</span>

<span class="sd">To do:</span>

<span class="sd">  - Set branchable aspect of TreeNode.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span> <span class="k">as</span> <span class="n">ddict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pptree</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">issparse</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">normalize</span>

<span class="c1"># from importlib import reload</span>
<span class="c1"># pptree = reload(pptree)</span>
<span class="c1"># import netflow.utils as utl</span>
<span class="kn">import</span> <span class="nn">netflow.utils</span> <span class="k">as</span> <span class="nn">utl</span>
<span class="c1"># from importlib import reload</span>
<span class="c1"># reload(utl)</span>
<span class="kn">from</span> <span class="nn">.similarity</span> <span class="kn">import</span> <span class="n">mutual_knn_edges</span>
<span class="c1"># from .._logging import logger, set_verbose ###</span>
<span class="kn">from</span> <span class="nn">.._logging</span> <span class="kn">import</span> <span class="n">_gen_logger</span><span class="p">,</span> <span class="n">set_verbose</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">_gen_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># RE: TODO: check how branches are connected to each other if flavor != &#39;haghverdi16&#39;</span>
<span class="c1"># RE: TODO: ADD OPTION FOR MULTIPLE ROOTS</span>
<span class="c1">### RE: TODO: CHECK HOW UNIQUE BRANCHES ARE DETERMINED</span>
<span class="c1"># RE: TODO: CHECK WHICH TRANSITION MATRIX IS USED AND HOW IT&#39;S DEFINED</span>
<span class="c1">### RE: TODO: CHECK HOW BRANCHING CONNECTIONS IS DEFINED WHEN THERE IS A TRUNK</span>
<span class="c1"># RE: TODO: IF MAX CORR &lt; THRESH, MAYBE DON&quot;T INCLUDE BRANCH?</span>
<span class="c1"># RE: TODO: ADD OPTION TO CHANGE ROOT AND UPDATE PSEUDOTIME, SEGS, AND ORDERING? -- this should be for earlier step in pipeline</span>
<span class="c1"># RE: TODO: SHOULD -1 be included in segs_names_unique?</span>

<div class="viewcode-block" id="get_pose"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.get_pose">[docs]</a><span class="k">def</span> <span class="nf">get_pose</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">n_branches</span><span class="p">,</span> <span class="n">until_branched</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
             <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_branch_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">choose_largest_segment</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">flavor</span><span class="o">=</span><span class="s1">&#39;haghverdi16&#39;</span><span class="p">,</span> <span class="n">allow_kendall_tau_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">smooth_corr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">brute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">connect_closest</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_trunk</span><span class="o">=</span><span class="s1">&#39;classic&#39;</span><span class="p">,</span>
             <span class="n">mutual</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">k_mnn</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
             <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute the pose and saved to keeper.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keeper : `netflow.Keeper`</span>
<span class="sd">        The keeper object that stores the distance matrix of size (n_observations, n_observations).</span>
<span class="sd">    key : `str`</span>
<span class="sd">        The label used to reference the distance matrix stored in ``keeper.distances``,</span>
<span class="sd">        of size (n_observations, n_observations).</span>
<span class="sd">    label : `str`</span>
<span class="sd">        Label used to store resulting schema in ``keeper.misc[label]`` and POSE topology in</span>
<span class="sd">        ``keeper.graphs[label]``..</span>
<span class="sd">    n_branches : `int`</span>
<span class="sd">            Number of branch splits to perform (``n_branches &gt; 0``).</span>
<span class="sd">    until_branched : `bool`</span>
<span class="sd">            If `True`, iteratively find segment to branch and perform branching</span>
<span class="sd">            until a segement is successfully branched or no branchable segments</span>
<span class="sd">            remain. Otherwise, if `False`, attempt to perform branching only once </span>
<span class="sd">            on the next potentially branchable segment.</span>
<span class="sd">    root : {`None`, `int`, &#39;density&#39;, &#39;density_inv&#39;, &#39;ratio&#39;}</span>
<span class="sd">        The root. If `None`, &#39;density&#39; is used.</span>

<span class="sd">        Options:</span>

<span class="sd">        - `int` : index of observation</span>
<span class="sd">        - &#39;density&#39; : select observation with minimal distance-density</span>
<span class="sd">        - &#39;density_inv&#39; : select observation with maximal distance-density</span>
<span class="sd">        - &#39;ratio&#39; : select observation which leads to maximal triangular ratio distance</span>
<span class="sd">    min_branch_size : {`int`, `float`}</span>
<span class="sd">        During recursive splitting of branches, only consider splitting a branch with at least</span>
<span class="sd">        ``min_branch_size &gt; 2`` data points.</span>
<span class="sd">        If a `float`, ``min_branch_size`` refers to the fraction of the total number of data points</span>
<span class="sd">        (``0 &lt; min_branch_size &lt; 1``).</span>
<span class="sd">    choose_largest_segment : `bool`</span>
<span class="sd">        If `True`, select largest segment for branching.</span>
<span class="sd">    flavor : {&#39;haghverdi16&#39;, &#39;wolf17_tri&#39;, &#39;wolf17_bi&#39;, &#39;wolf17_bi_un&#39;}</span>
<span class="sd">        Branching algorithm (based on `scanpy` implementation).</span>
<span class="sd">    allow_kendall_tau_shift : `bool`</span>
<span class="sd">        If a very small branch is detected upon splitting, shift away from</span>
<span class="sd">        maximum correlation in Kendall tau criterion of [Haghverdi16]_ to</span>
<span class="sd">        stabilize the splitting.</span>
<span class="sd">    smooth_corr : `bool`, default = `False`</span>
<span class="sd">        If `True`, smooth correlations before identifying cut points for branch splitting.</span>
<span class="sd">    brute : `bool`</span>
<span class="sd">        If `True`, data points not associated with any branch upon split are combined with</span>
<span class="sd">        undecided (trunk) points. Otherwise, if `False`, they are treated as individual islands,</span>
<span class="sd">        not associated with any branch (and assigned branch index -1).</span>
<span class="sd">    split : `bool` (default = True)</span>
<span class="sd">        if `True`, split segment into multiple branches. Otherwise,</span>
<span class="sd">        determine a single branching off of the main segment.</span>
<span class="sd">        This is ignored if flavor is not &#39;haghverdi16&#39;.</span>
<span class="sd">        If `True`, ``brute`` is ignored.</span>
<span class="sd">    mutual : `bool` (default = `False`)</span>
<span class="sd">        If `True`, add ``k_mnn`` mutual nn edges. Otherwise, add single nn edge.</span>
<span class="sd">        When `False`, ``k_mnn`` is ignored.</span>
<span class="sd">    k_mnn : `int` (``0 &lt; k_mnn &lt; len(G)``)</span>
<span class="sd">        The number of nns to consider when extracting mutual nns.</span>
<span class="sd">        Note, this is ignored when ``mutual`` is `False`.</span>
<span class="sd">    connect_closest : `bool` (default = False)</span>
<span class="sd">        If `True`, connect branches by points with smallest distance between the branches.</span>
<span class="sd">        Otherwise, connect by continuum of ordering.</span>
<span class="sd">    connect_trunk : {&#39;classic&#39;, &#39;endpoint&#39;, &#39;dual&#39;}, default = &#39;classic&#39;</span>
<span class="sd">        Specify how to connect segments to unresolved/unidentified trunk.</span>
<span class="sd">        Note, this only applies when a split results in a trunk consisting of unresolved/unidentified points.</span>
<span class="sd">        Additionally, this is ignored if ``flavor ~= &#39;haghverdi16&#39;``.</span>
<span class="sd">        It is also ignored If ``flavor = `haghverdi16&#39;`` and ``split = False``.</span>

<span class="sd">        Options:</span>

<span class="sd">        - `classic` : point identified in trunk is connected to the point in the segment closest to it</span>
<span class="sd">        - `endpoint` : point identified in trunk is connected to the the segment&#39;s second tip</span>
<span class="sd">        - `dual` : point identified in trunk is connected to both points determined by `classic` and `endpoint`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Writes the following to the keeper :</span>

<span class="sd">      - poser : `POSER`</span>

<span class="sd">        * The poser object with the pseudo-organizational branching structure</span>
<span class="sd">          is stored in ``keeper.misc[&#39;poser_{label}&#39;]``.</span>
<span class="sd">      - G_pose : `networkx.Graph`    </span>

<span class="sd">        * The resulting pose topology is stored in ``keeper.graphs[&#39;pose_{label}&#39;]``.</span>
<span class="sd">      - G_pose_nn : `networkx.Graph`</span>

<span class="sd">        * The resulting pose + nearest-neighbor (nn) topology is stored in</span>
<span class="sd">          ``keeper.graphs[&#39;pose_nn_{label}]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">poser</span> <span class="o">=</span> <span class="n">POSER</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
                  <span class="n">min_branch_size</span><span class="o">=</span><span class="n">min_branch_size</span><span class="p">,</span> <span class="n">choose_largest_segment</span><span class="o">=</span><span class="n">choose_largest_segment</span><span class="p">,</span>
                  <span class="n">connect_closest</span><span class="o">=</span><span class="n">connect_closest</span><span class="p">,</span> <span class="n">connect_trunk</span><span class="o">=</span><span class="n">connect_trunk</span><span class="p">,</span>
                  <span class="n">flavor</span><span class="o">=</span><span class="n">flavor</span><span class="p">,</span> <span class="n">allow_kendall_tau_shift</span><span class="o">=</span><span class="n">allow_kendall_tau_shift</span><span class="p">,</span>
                  <span class="n">smooth_corr</span><span class="o">=</span><span class="n">smooth_corr</span><span class="p">,</span> <span class="n">brute</span><span class="o">=</span><span class="n">brute</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="n">split</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">G_pose</span> <span class="o">=</span> <span class="n">poser</span><span class="o">.</span><span class="n">branchings_segments</span><span class="p">(</span><span class="n">n_branches</span><span class="p">,</span> <span class="n">until_branched</span><span class="o">=</span><span class="n">until_branched</span><span class="p">)</span>
    <span class="n">G_pose</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;pose_&#39;</span> <span class="o">+</span> <span class="n">label</span>
    <span class="n">keeper</span><span class="o">.</span><span class="n">add_misc</span><span class="p">(</span><span class="n">poser</span><span class="p">,</span> <span class="s1">&#39;poser_&#39;</span> <span class="o">+</span> <span class="n">label</span><span class="p">)</span>
    <span class="n">keeper</span><span class="o">.</span><span class="n">add_graph</span><span class="p">(</span><span class="n">G_pose</span><span class="p">,</span> <span class="s1">&#39;pose_&#39;</span> <span class="o">+</span> <span class="n">label</span><span class="p">)</span>

    <span class="n">G_pose_nn</span> <span class="o">=</span> <span class="n">poser</span><span class="o">.</span><span class="n">construct_pose_nn_topology</span><span class="p">(</span><span class="n">G_pose</span><span class="p">,</span> <span class="n">mutual</span><span class="o">=</span><span class="n">mutual</span><span class="p">,</span> <span class="n">k_mnn</span><span class="o">=</span><span class="n">k_mnn</span><span class="p">)</span>
    <span class="n">pre_label</span> <span class="o">=</span> <span class="s1">&#39;pose_mnn_&#39;</span> <span class="k">if</span> <span class="n">mutual</span> <span class="k">else</span> <span class="s1">&#39;pose_nn_&#39;</span>
    <span class="n">G_pose_nn</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">pre_label</span> <span class="o">+</span> <span class="n">label</span>
    <span class="n">keeper</span><span class="o">.</span><span class="n">add_graph</span><span class="p">(</span><span class="n">G_pose_nn</span><span class="p">,</span> <span class="n">pre_label</span> <span class="o">+</span> <span class="n">label</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeNode"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TreeNode">[docs]</a><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Node of a general tree data structure.</span>

<span class="sd">    Each node is intended to refer to a branch.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name</span>
<span class="sd">        Reference name of node (branch).</span>
<span class="sd">    data </span>
<span class="sd">        Data associated with the node.</span>
<span class="sd">        Intended to be a `list` of indices corresponding to the branch members.</span>
<span class="sd">    children : `list` [`TreeNode`]</span>
<span class="sd">        List of children `TreeNode` objects.</span>
<span class="sd">    parent : `TreeNode`</span>
<span class="sd">        Parent `TreeNode` object.</span>
<span class="sd">    nonunique : `bool`</span>
<span class="sd">        Indicate if node (branch) is the trunk.</span>
<span class="sd">    unidentified : `bool`</span>
<span class="sd">        Indicate if node (branch) is a set of points that were not identified</span>
<span class="sd">        with a particular branch after splitting.</span>
<span class="sd">    branchable : `bool`</span>
<span class="sd">        Indicate if node can potentially be further branched.</span>
<span class="sd">    is_trunk : `bool`</span>
<span class="sd">        Indicate if node referes to undecided trunk branch.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TreeNode.__init__"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TreeNode.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">nonunique</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unidentified</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">branchable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_trunk</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nonunique</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_string</span> <span class="o">=</span> <span class="s2">&quot; - &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">name_string</span><span class="p">,</span> <span class="s1">&#39;trunk&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_string</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; (n = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nonunique</span> <span class="o">=</span> <span class="n">nonunique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unidentified</span> <span class="o">=</span> <span class="n">unidentified</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">branchable</span> <span class="o">=</span> <span class="n">branchable</span> <span class="c1"># True # indicate if branch can be further split</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_trunk</span> <span class="o">=</span> <span class="n">is_trunk</span> <span class="c1"># undecided</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tips</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connections</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># used to indicate the order in which nodes are inserted and as unique identifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">=</span> <span class="kc">None</span>         </div>


<div class="viewcode-block" id="TreeNode.__repr__"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TreeNode.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_string</span></div>

    
<div class="viewcode-block" id="TreeNode.is_root"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TreeNode.is_root">[docs]</a>    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

        
<div class="viewcode-block" id="TreeNode.is_leaf"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TreeNode.is_leaf">[docs]</a>    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

        
<div class="viewcode-block" id="TreeNode.depth"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TreeNode.depth">[docs]</a>    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Depth of current node. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span></div>

        
<div class="viewcode-block" id="TreeNode.add_child"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TreeNode.add_child">[docs]</a>    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Add child to node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : `TreeNode`</span>
<span class="sd">            The child node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unrecognized type, node must be a TreeNode.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeNode.contains"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TreeNode.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Check if value is in data. &quot;&quot;&quot;</span>
        <span class="n">found</span> <span class="o">=</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">return</span> <span class="n">found</span></div>


<div class="viewcode-block" id="TreeNode.disp"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TreeNode.disp">[docs]</a>    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cur_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">pptree</span><span class="o">.</span><span class="n">print_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;children&#39;</span><span class="p">,</span> <span class="s1">&#39;name_string&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">cur_name</span></div></div>


<div class="viewcode-block" id="Tree"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree">[docs]</a><span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tree implemenation as a collection of TreeNode objects.</span>

<span class="sd">    Intended to represent the hierarchical branching.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Tree.__init__"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># self.height = 0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># self.node_adjacency = ddict(list)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_connection</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># ddict(list)</span></div>


<div class="viewcode-block" id="Tree.disp"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.disp">[docs]</a>    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">disp</span><span class="p">())</span></div>
        

<div class="viewcode-block" id="Tree.insert"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Insert a node into the Tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : `TreeNode`</span>
<span class="sd">            Node to insert.</span>
<span class="sd">        index : {`None`, `int`}</span>
<span class="sd">            Index in list of nodes where the node should be inserted.</span>
<span class="sd">            (Intended to match current structure for updating segments</span>
<span class="sd">            until tree structure is fully leveraged (e.g., using tree</span>
<span class="sd">            leaf nodes when searching for which segment to select).</span>

<span class="sd">            If `None`, the node is appended to the end of the list.</span>
<span class="sd">        parent : {`None`, `TreeNode`}</span>
<span class="sd">            Parent node. If `None`, node is set as the root node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;The first node inserted into the tree must be the root node with no parent.&quot;</span><span class="p">)</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">node</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

        <span class="n">node</span><span class="o">.</span><span class="n">_counter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Tree.get_node_from_name"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.get_node_from_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_from_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bottom_up</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Search and return node in Tree by its name.</span>

<span class="sd">        Assumes no nodes at the same depth have the same name.</span>
<span class="sd">        If more than one node has the same name, return the node</span>
<span class="sd">        of the deepest node (farthest from root), when</span>
<span class="sd">        ``bottom_up = True``, otherwise, return the index of the </span>
<span class="sd">        shallowest (closest to root) node.</span>

<span class="sd">        If no such node is found with the specified name, `None`</span>
<span class="sd">        is returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name</span>
<span class="sd">            Name of node to search for.</span>
<span class="sd">        bottom_up : `bool`</span>
<span class="sd">            Indicate if the index of the shallowest or deepest node</span>
<span class="sd">            should be returned when more than one node has the same</span>
<span class="sd">            name. It is assumed that no two nodes at the same depth</span>
<span class="sd">            have the same name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        node : `TreeNode`</span>
<span class="sd">            Node in the tree. If node is not found, returns `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bottom_up</span><span class="o">=</span><span class="n">bottom_up</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">node</span></div>
            

<div class="viewcode-block" id="Tree.search"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.search">[docs]</a>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bottom_up</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Search and return index of node in Tree by its name.</span>

<span class="sd">        Assumes no nodes at the same depth have the same name.</span>
<span class="sd">        If more than one node has the same name, return the index</span>
<span class="sd">        of the deepest node (farthest from root), when</span>
<span class="sd">        ``bottom_up = True``, otherwise, return the index of the </span>
<span class="sd">        shallowest (closest to root) node.</span>

<span class="sd">        If no such node is found with the specified name, the</span>
<span class="sd">        value -1 is returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name</span>
<span class="sd">            Name of node to search for.</span>
<span class="sd">        bottom_up : `bool`</span>
<span class="sd">            Indicate if the index of the shallowest or deepest node</span>
<span class="sd">            should be returned when more than one node has the same</span>
<span class="sd">            name. It is assumed that no two nodes at the same depth</span>
<span class="sd">            have the same name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : `int`</span>
<span class="sd">            Index of node in the tree. If node is not found, returns -1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ix</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">depth</span><span class="p">())</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">bottom_up</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># found = False</span>
        <span class="c1"># for ix, node in enumerate(self.nodes):</span>
        <span class="c1">#     if node.name == name:</span>
        <span class="c1">#         found = True</span>
        <span class="c1">#         break</span>
        <span class="c1"># index = ix if found else -1</span>
        
        <span class="k">return</span> <span class="n">index</span></div>


<div class="viewcode-block" id="Tree.search_data"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.search_data">[docs]</a>    <span class="k">def</span> <span class="nf">search_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">bottom_up</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Search and return index of node in Tree with value in node data.</span>

<span class="sd">        If the value is in the data of more than one node, return the index</span>
<span class="sd">        of the deepest node (farthest from root), when</span>
<span class="sd">        ``bottom_up = True``, otherwise, return the index of the shallowest </span>
<span class="sd">        (closest to root) node.</span>

<span class="sd">        If no such node is found with the specified value in its data, the</span>
<span class="sd">        value -1 is returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value</span>
<span class="sd">            Value in node data to search for.</span>
<span class="sd">        bottom_up : `bool`</span>
<span class="sd">            Indicate if the index of the shallowest or deepest node</span>
<span class="sd">            should be returned when more than one node has the same</span>
<span class="sd">            name. It is assumed that no two nodes at the same depth</span>
<span class="sd">            have the same name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : `int`</span>
<span class="sd">            Index of node in the tree. If node is not found, returns -1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ix</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">depth</span><span class="p">())</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">bottom_up</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># found = False</span>
        <span class="c1"># for ix, node in enumerate(self.nodes):</span>
        <span class="c1">#     if node.name == name:</span>
        <span class="c1">#         found = True</span>
        <span class="c1">#         break</span>
        <span class="c1"># index = ix if found else -1</span>
        
        <span class="k">return</span> <span class="n">index</span></div>

    
<div class="viewcode-block" id="Tree.get_node"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.get_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return node by its index. &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">node</span></div>


<div class="viewcode-block" id="Tree._get_node_from_counter"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree._get_node_from_counter">[docs]</a>    <span class="k">def</span> <span class="nf">_get_node_from_counter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">counter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Search and return node in Tree by its counter ID.</span>

<span class="sd">        Assumes no nodes have the same counter ID.</span>

<span class="sd">        If no such node is found with the specified counter, `None`</span>
<span class="sd">        is returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        counter : `int`</span>
<span class="sd">            Counter ID of node to search for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        node : `TreeNode`</span>
<span class="sd">            Node in the tree. If node is not found, returns `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_counter</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">node</span></div>


<div class="viewcode-block" id="Tree._search_counter"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree._search_counter">[docs]</a>    <span class="k">def</span> <span class="nf">_search_counter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">counter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Search and return index of node in Tree by its counter ID.</span>

<span class="sd">        Assumes no nodes have the same couner.</span>

<span class="sd">        If no such node is found with the specified counter, the</span>
<span class="sd">        value -1 is returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        counter : `int`</span>
<span class="sd">            Counter ID of node to search for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : `int`</span>
<span class="sd">            Index of node in the tree. If node is not found, returns -1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ix</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_counter</span> <span class="o">==</span> <span class="n">counter</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected number of nodes found with the same counter, expected to be unique.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">index</span></div>
    
    
<div class="viewcode-block" id="Tree.root"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.root">[docs]</a>    <span class="k">def</span> <span class="nf">root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span></div>


<div class="viewcode-block" id="Tree.max_depth"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.max_depth">[docs]</a>    <span class="k">def</span> <span class="nf">max_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return max depth of the tree. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">])</span></div>


<div class="viewcode-block" id="Tree.all_data"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.all_data">[docs]</a>    <span class="k">def</span> <span class="nf">all_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return sorted set of all data points in all nodes in the tree. &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="Tree.get_leaves_indices"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.get_leaves_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_leaves_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return indices of leaf nodes in the tree. &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">ix</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">indices</span></div>
    

<div class="viewcode-block" id="Tree.get_leaves"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.get_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return leaf nodes in the tree. &quot;&quot;&quot;</span>
        <span class="n">leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">leaves</span></div>


<div class="viewcode-block" id="Tree.co_branch_indicator"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.Tree.co_branch_indicator">[docs]</a>    <span class="k">def</span> <span class="nf">co_branch_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return binary symmetric `pandas.DataFrame` of size (num_data_points, num_data_points)</span>
<span class="sd">        where the (i,j)-th entry is 1 if the i-th and j-th data points are found in the same node</span>
<span class="sd">        (i.e., branch) and i is not the same data point as j. Otherwise, if i = j, or if the i-th</span>
<span class="sd">        and j-th data points are not found in the same node, the (i.j)-th entry is 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">()</span>
        <span class="n">co_tracker</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data_points</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">obs_a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_points</span><span class="p">):</span>
            <span class="n">co_tracker</span><span class="p">[</span><span class="n">obs_a</span><span class="p">][</span><span class="n">obs_a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">search_data</span><span class="p">(</span><span class="n">obs_a</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(),</span> <span class="s2">&quot;Expected leaf node.&quot;</span>

            <span class="k">for</span> <span class="n">obs_b</span> <span class="ow">in</span> <span class="n">data_points</span><span class="p">[</span><span class="n">ix</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">obs_b</span><span class="p">):</span>
                    <span class="n">co_tracker</span><span class="p">[</span><span class="n">obs_a</span><span class="p">][</span><span class="n">obs_b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">co_tracker</span><span class="p">[</span><span class="n">obs_b</span><span class="p">][</span><span class="n">obs_a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">co_tracker</span><span class="p">[</span><span class="n">obs_a</span><span class="p">][</span><span class="n">obs_b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">co_tracker</span><span class="p">[</span><span class="n">obs_b</span><span class="p">][</span><span class="n">obs_a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">co_tracker</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">co_tracker</span><span class="p">)</span>
        <span class="c1"># ensure symmetric and sorted:</span>
        <span class="n">co_tracker</span> <span class="o">=</span> <span class="n">co_tracker</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_points</span><span class="p">,</span> <span class="n">data_points</span><span class="p">]</span> 
        <span class="k">return</span> <span class="n">co_tracker</span></div></div>

        
<div class="viewcode-block" id="_compute_transitions"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization._compute_transitions">[docs]</a><span class="k">def</span> <span class="nf">_compute_transitions</span><span class="p">(</span><span class="n">similarity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density_normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute transition matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    similarity : `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">        Symmetric similarity measure (with 1s on the diagonal).</span>
<span class="sd">    density_normalize : `bool`</span>
<span class="sd">        The density rescaling of Coifman and Lafon (2006): Then only the</span>
<span class="sd">        geometry of the data matters, not the sampled density.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    transitions_asym : `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">        Asymmetric Transition matrix.</span>
<span class="sd">    transitions_sym : `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">        Symmetric Transition matrix.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Code copied from `scanpy.neighbors`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">W</span> <span class="o">=</span> <span class="n">similarity</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># set diagonal to zero:</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
    
    <span class="c1"># density normalization as of Coifman et al. (2005)</span>
    <span class="c1"># ensures that kernel matrix is independent of sampling density</span>
    <span class="k">if</span> <span class="n">density_normalize</span><span class="p">:</span>
        <span class="c1"># q[i] is an estimate for the sampling density at point i</span>
        <span class="c1"># it&#39;s also the degree of the underlying graph</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">issparse</span><span class="p">(</span><span class="n">W</span><span class="p">):</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">@</span> <span class="n">W</span> <span class="o">@</span> <span class="n">Q</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">W</span>

    <span class="c1"># asym transitions</span>
    <span class="c1"># z[i] is the row sum of K</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">issparse</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">transitions_asym</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">@</span> <span class="n">K</span>

    <span class="c1"># sym transitions</span>
    <span class="c1"># z[i] is the square root of the row sum of K</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">issparse</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">transitions_sym</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">Z</span>

    <span class="c1"># to compute first eigenvector phi0 if did density normalization (from matlab code):</span>
    <span class="c1"># D1_ = np.asarray(K.sum(axis=0))</span>
    <span class="c1"># phi0 = D1_ / np.sqrt(np.power(D1_, 2).sum())  # TODO: check if ever need this to be sparse</span>

    <span class="k">return</span> <span class="n">transitions_asym</span><span class="p">,</span> <span class="n">transitions_sym</span></div>
    
    
<div class="viewcode-block" id="compute_transitions"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.compute_transitions">[docs]</a><span class="k">def</span> <span class="nf">compute_transitions</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">similarity_key</span><span class="p">,</span> <span class="n">density_normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute symmetric and asymmetric transition matrices and store in keeper.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keeper : `netflow.Keeper`</span>
<span class="sd">        The keeper object.</span>
<span class="sd">    similarity_key : `str`</span>
<span class="sd">        Reference key to the `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">        symmetric similarity measure (with 1s on the diagonal) stored in the similarities</span>
<span class="sd">        in the keeper.</span>
<span class="sd">    density_normalize : `bool`</span>
<span class="sd">        The density rescaling of Coifman and Lafon (2006): Then only the</span>
<span class="sd">        geometry of the data matters, not the sampled density.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Adds the following to the keeper.misc (with 0s on the diagonals):</span>
<span class="sd">        transitions_asym_{similarity_key} : `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">            Asymmetric Transition matrix.</span>
<span class="sd">        transitions_sym_{similarity_key} : `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">            Symmetric Transition matrix.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Code primarily copied from `scanpy.neighbors`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">similarity</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">similarities</span><span class="p">[</span><span class="n">similarity_key</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    
    <span class="n">transitions_asym</span><span class="p">,</span> <span class="n">transitions_sym</span> <span class="o">=</span> <span class="n">_compute_transitions</span><span class="p">(</span><span class="n">similarity</span><span class="o">=</span><span class="n">similarity</span><span class="p">,</span>
                                                             <span class="n">density_normalize</span><span class="o">=</span><span class="n">density_normalize</span><span class="p">)</span>

    <span class="n">asym_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;transitions_asym_</span><span class="si">{</span><span class="n">similarity_key</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">sym_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;transitions_sym_</span><span class="si">{</span><span class="n">similarity_key</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="n">density_normalize</span><span class="p">:</span>
        <span class="n">asym_label</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">asym_label</span><span class="p">,</span> <span class="s2">&quot;density_normalized&quot;</span><span class="p">])</span>
        <span class="n">sym_label</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">sym_label</span><span class="p">,</span> <span class="s2">&quot;density_normalized&quot;</span><span class="p">])</span>
        
    <span class="c1"># if label is not None:</span>
    <span class="c1">#     asym_label = &quot;_&quot;.join([asym_label, label])</span>
    <span class="c1">#     sym_label = &quot;_&quot;.join([sym_label, label])</span>

    <span class="n">keeper</span><span class="o">.</span><span class="n">add_misc</span><span class="p">(</span><span class="n">transitions_asym</span><span class="p">,</span> <span class="n">asym_label</span><span class="p">)</span>
    <span class="n">keeper</span><span class="o">.</span><span class="n">add_misc</span><span class="p">(</span><span class="n">transitions_sym</span><span class="p">,</span> <span class="n">sym_label</span><span class="p">)</span></div>


<div class="viewcode-block" id="compute_rw_transitions"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.compute_rw_transitions">[docs]</a><span class="k">def</span> <span class="nf">compute_rw_transitions</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">similarity_key</span><span class="p">,</span> <span class="n">do_save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute the row-stochastic transition matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keeper : `netflow.Keeper`</span>
<span class="sd">        The keeper object.</span>
<span class="sd">    similarity_key : `str`</span>
<span class="sd">        Reference key to the `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">        symmetric similarity measure (with 1s on the diagonal) stored in the similarities</span>
<span class="sd">        in the keeper.</span>
<span class="sd">    do_save : `bool`</span>
<span class="sd">        If `True`, save to ``keeper``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : `numpy.ndarray` (n_observations, n_observations)</span>
<span class="sd">        The row-stochastic transition matrix (with 0s on the diagonals).</span>
<span class="sd">        If ``do_save`` is `True`, ``P`` is added to the ``keeper.misc`` with the key ``&#39;transitions_rw_{similarity_key}&#39;``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">similarity</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">similarities</span><span class="p">[</span><span class="n">similarity_key</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">similarity</span><span class="p">,</span> <span class="s2">&quot;l1&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">do_save</span><span class="p">:</span>
        <span class="n">P_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;transitions_rw_</span><span class="si">{</span><span class="n">similarity_key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">keeper</span><span class="o">.</span><span class="n">add_misc</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">P_label</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">P</span></div>


<div class="viewcode-block" id="compute_sym_diffusion_affinity_transitions"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.compute_sym_diffusion_affinity_transitions">[docs]</a><span class="k">def</span> <span class="nf">compute_sym_diffusion_affinity_transitions</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">similarity_key</span><span class="p">,</span> <span class="n">do_save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute the symmetric diffusion affinity transition matrix from</span>
<span class="sd">    https://github.com/KrishnaswamyLab/graphtools/blob/master/graphtools/base.py.</span>

<span class="sd">    .. math:: P_{ij} = K_{ij} * (d_i * d_j)^{-1/2}</span>

<span class="sd">    where :math:`d_i = \sum_r K_{ir}` is the degree (row sum) of observation :math:`i`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keeper : `netflow.Keeper`</span>
<span class="sd">        The keeper object.</span>
<span class="sd">    similarity_key : `str`</span>
<span class="sd">        Reference key to the `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">        symmetric similarity measure (with 1s on the diagonal) stored in the similarities</span>
<span class="sd">        in the keeper.</span>
<span class="sd">    do_save : `bool`</span>
<span class="sd">        If `True`, save to ``keeper``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : `numpy.ndarray` (n_observations, n_observations)</span>
<span class="sd">        The symmetric diffusion affinity transition matrix (with 0s on the diagonals).</span>
<span class="sd">        If ``do_save`` is `True`, ``P`` is added to the ``keeper.misc`` with the key ``&#39;transitions_sym_diff_aff_{similarity_key}&#39;``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">similarity</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">similarities</span><span class="p">[</span><span class="n">similarity_key</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">row_degrees</span> <span class="o">=</span> <span class="n">similarity</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">col_degrees</span> <span class="o">=</span> <span class="n">similarity</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:]</span>
    
    <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">similarity</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">row_degrees</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">col_degrees</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">do_save</span><span class="p">:</span>
        <span class="n">P_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;transitions_sym_diff_aff_</span><span class="si">{</span><span class="n">similarity_key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">keeper</span><span class="o">.</span><span class="n">add_misc</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">P_label</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">P</span></div>



<div class="viewcode-block" id="compute_multiscale_VNE_transitions_from_similarity"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.compute_multiscale_VNE_transitions_from_similarity">[docs]</a><span class="k">def</span> <span class="nf">compute_multiscale_VNE_transitions_from_similarity</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">similarity_key</span><span class="p">,</span>
                                                       <span class="n">tau_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">do_save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute the multi-scale transition matrix based on the elbow of the Von Neumann Entropy (VNE)</span>
<span class="sd">    as described in GSPA and PHATE https://github.com/KrishnaswamyLab/spARC/blob/main/SPARC/vne.py,</span>
<span class="sd">    https://pdfs.semanticscholar.org/16ab/e92b7630d5b84b904bde97dad9b9fbce406c.pdf.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keeper : `netflow.Keeper`</span>
<span class="sd">        The keeper object.</span>
<span class="sd">    similarity_key : `str`</span>
<span class="sd">        Reference key to the `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">        symmetric similarity measure (with 1s on the diagonal) stored in the similarities</span>
<span class="sd">        in the keeper.</span>
<span class="sd">    tau_max : `int`</span>
<span class="sd">        Max scale ``tau`` tested for VNE (default is 100).</span>
<span class="sd">    do_save : `bool`</span>
<span class="sd">        If `True`, save to ``keeper``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : `numpy.ndarray` (n_observations, n_observations)</span>
<span class="sd">        The symmetric VNE multi-scale transition matrix (with 0s on the diagonals).</span>
<span class="sd">        If ``do_save`` is `True`, ``P`` is added to the ``keeper.misc`` with the key ``&#39;transitions_sym_multiscaleVNE_{similarity_key}&#39;``</span>
<span class="sd">    P_asym : `numpy.ndarray` (n_observations, n_observations)</span>
<span class="sd">        The random-walk VNE multi-scale transition matrix (with 0s on the diagonals).</span>
<span class="sd">        If ``do_save`` is `True`, ``P_asym`` is added to the ``keeper.misc`` with the key ``&#39;transitions_multiscaleVNE_{similarity_key}&#39;``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P_sym_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;transitions_sym_multiscaleVNE_</span><span class="si">{</span><span class="n">similarity_key</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">P_asym_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;transitions_multiscaleVNE_</span><span class="si">{</span><span class="n">similarity_key</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="n">P_sym_label</span> <span class="ow">in</span> <span class="n">keeper</span><span class="o">.</span><span class="n">misc</span> <span class="ow">and</span> <span class="n">P_asym_label</span> <span class="ow">in</span> <span class="n">keeper</span><span class="o">.</span><span class="n">misc</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">misc</span><span class="p">[</span><span class="n">P_sym_label</span><span class="p">]</span>
        <span class="n">P_asym</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">misc</span><span class="p">[</span><span class="n">P_asym_label</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">P_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;transitions_sym_diff_aff_</span><span class="si">{</span><span class="n">similarity_key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">P_label</span> <span class="ow">in</span> <span class="n">keeper</span><span class="o">.</span><span class="n">misc</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">misc</span><span class="p">[</span><span class="n">P_label</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">compute_sym_diffusion_affinity_transitions</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">similarity_key</span><span class="p">,</span> <span class="n">do_save</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">vne</span> <span class="o">=</span> <span class="n">utl</span><span class="o">.</span><span class="n">von_neumann_entropy</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">tau_max</span><span class="o">=</span><span class="n">tau_max</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">utl</span><span class="o">.</span><span class="n">find_knee_point</span><span class="p">(</span><span class="n">vne</span><span class="p">)</span>

        <span class="c1"># if not use_affinity_diffusion_matrix:</span>
        <span class="c1">#    P = compute_rw_transitions(keeper, similarity_key, do_save=False)    </span>

        <span class="n">P_rw_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;transitions_rw_</span><span class="si">{</span><span class="n">similarity_key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">P_rw_label</span> <span class="ow">in</span> <span class="n">keeper</span><span class="o">.</span><span class="n">misc</span><span class="p">:</span>
            <span class="n">P_asym</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">misc</span><span class="p">[</span><span class="n">P_rw_label</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P_asym</span> <span class="o">=</span> <span class="n">compute_rw_transitions</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">similarity_key</span><span class="p">,</span> <span class="n">do_save</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
        <span class="n">P_asym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">P_asym</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">do_save</span><span class="p">:</span>
            <span class="c1"># if use_affinity_diffusion_matrix:</span>
            <span class="c1">#     P_label = f&quot;transitions_sym_multiscaleVNE_{similarity_key}&quot;</span>
            <span class="c1"># else:</span>
            <span class="c1">#     P_label = f&quot;transitions_multiscaleVNE_{similarity_key}&quot;</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">keeper</span><span class="o">.</span><span class="n">add_misc</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">P_sym_label</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">keeer</span><span class="o">.</span><span class="n">misc</span><span class="p">[</span><span class="n">P_sym_label</span><span class="p">]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returning pre-computed </span><span class="si">{</span><span class="n">P_sym_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">keeper</span><span class="o">.</span><span class="n">add_misc</span><span class="p">(</span><span class="n">P_asym</span><span class="p">,</span> <span class="n">P_asym_label</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">P_asym</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">misc</span><span class="p">[</span><span class="n">P_asym_label</span><span class="p">]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returning pre-computed </span><span class="si">{</span><span class="n">P_sym_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">P_asym</span></div>


<div class="viewcode-block" id="_dpt_from_augmented_sym_transitions"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization._dpt_from_augmented_sym_transitions">[docs]</a><span class="k">def</span> <span class="nf">_dpt_from_augmented_sym_transitions</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">n_comps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">return_eigs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the diffusion pseudotime metric between observations,</span>
<span class="sd">    computed from the symmetric transitions.</span>

<span class="sd">    .. Note::</span>

<span class="sd">        - :math:`T` is the symmetric transition matrix</span>
<span class="sd">        - :math:`M(x,z) = \sum_{i=1}^{n-1} (\lambda_i * (1 - \lambda_i))\psi_i(x)\psi_i^T(z)`</span>
<span class="sd">        - :math:`dpt(x,z) = ||M(x, .) - M(y, .)||^2`</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    T : `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">        Symmetric transitions.</span>
<span class="sd">    n_comps</span>
<span class="sd">        Number of eigenvalues/vectors to be computed,</span>
<span class="sd">        set ``n_comps = 0`` to compute the whole spectrum.</span>
<span class="sd">        Alternatively, if set ``n_comps &gt;= n_observations``,</span>
<span class="sd">        the whole spectrum will be computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dpt : `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">        Pairwise-observation Diffusion pseudotime distances.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">utl</span><span class="o">.</span><span class="n">compute_eigen</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="n">n_comps</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="s2">&quot;decrease&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.8e-2</span><span class="p">:</span> <span class="c1"># 1e-2:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Largest eigenvalue is expected to be close to 1, found to be </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">evals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected second largest eigenvalue to be less than 1, found to be </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">evals</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">EVALS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">evals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">evals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">evecs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">@</span> <span class="n">EVALS</span> <span class="o">@</span> <span class="n">evecs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span>
    <span class="n">dpt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_eigs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dpt</span><span class="p">,</span> <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span>
    
    <span class="k">return</span> <span class="n">dpt</span></div>


<div class="viewcode-block" id="dpt_from_augmented_sym_transitions"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.dpt_from_augmented_sym_transitions">[docs]</a><span class="k">def</span> <span class="nf">dpt_from_augmented_sym_transitions</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">n_comps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">save_eig</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute the diffusion pseudotime metric between observations,</span>
<span class="sd">    computed from the symmetric transitions.</span>

<span class="sd">    .. Note::</span>

<span class="sd">        - :math:`T` is the symmetric transition matrix</span>
<span class="sd">        - :math:`M(x,z) = \sum_{i=1}^{n-1} (\lambda_i * (1 - \lambda_i))\psi_i(x)\psi_i^T(z)`</span>
<span class="sd">        - :math:`dpt(x,z) = ||M(x, .) - M(y, .)||^2`</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key : `str`</span>
<span class="sd">        Reference ID for the symmetric transitions</span>
<span class="sd">        `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">        stored in ``keeper.misc``.</span>
<span class="sd">    n_comps</span>
<span class="sd">        Number of eigenvalues/vectors to be computed,</span>
<span class="sd">        set ``n_comps = 0`` to compute the whole spectrum.</span>
<span class="sd">        Alternatively, if set ``n_comps &gt;= n_observations``,</span>
<span class="sd">        the whole spectrum will be computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dpt : `numpy.ndarray`, (n_observations, n_observations)</span>
<span class="sd">        Pairwise-observation Diffusion pseudotime distances are stored</span>
<span class="sd">        in keeper.distances[dpt_key] where ``dpt_key=&quot;dpt_from_{key}&quot;``.</span>
<span class="sd">        If the full spectrum is not used (i.e., ``0 &lt; n_comps &lt; n_observations&quot;``),</span>
<span class="sd">        then ``dpt_key=&quot;dpt_from_{key}_{n_comps}comps&quot;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">misc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    
    <span class="n">dpt</span><span class="p">,</span> <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">_dpt_from_augmented_sym_transitions</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="n">n_comps</span><span class="p">,</span> <span class="n">return_eigs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">dpt_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;dpt_from_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">n_comps</span> <span class="o">&lt;</span> <span class="n">keeper</span><span class="o">.</span><span class="n">num_observations</span><span class="p">:</span>
        <span class="n">dpt_key</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">dpt_key</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_comps</span><span class="si">}</span><span class="s2">comps&quot;</span><span class="p">])</span>
    <span class="n">keeper</span><span class="o">.</span><span class="n">add_distance</span><span class="p">(</span><span class="n">dpt</span><span class="p">,</span> <span class="n">dpt_key</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">save_eig</span><span class="p">:</span>
        <span class="n">keeper</span><span class="o">.</span><span class="n">add_misc</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">dpt_key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;dpt_from&#39;</span><span class="p">,</span> <span class="s1">&#39;evals&#39;</span><span class="p">))</span>
        <span class="n">keeper</span><span class="o">.</span><span class="n">add_misc</span><span class="p">(</span><span class="n">evecs</span><span class="p">,</span> <span class="n">dpt_key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;dpt_from&#39;</span><span class="p">,</span> <span class="s1">&#39;evecs&#39;</span><span class="p">))</span></div>
    

<div class="viewcode-block" id="root_max_ratio"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.root_max_ratio">[docs]</a><span class="k">def</span> <span class="nf">root_max_ratio</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Returns root index of observation that leads to the largest triangle..</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keeper : `netflow.Keeper`</span>
<span class="sd">       The keeper object.</span>
<span class="sd">    key : `str`</span>
<span class="sd">        Reference key of distance in keeper used to determine the root.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    root : `int`</span>
<span class="sd">        The root index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
    <span class="n">max_d_pairs</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
    <span class="n">sum_max_d_pairs</span> <span class="o">=</span> <span class="n">max_d_pairs</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]])</span>
    <span class="n">tip3</span> <span class="o">=</span> <span class="n">sum_max_d_pairs</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>

    <span class="n">max_d_pairs</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;tip2&#39;</span>
    <span class="n">tip3</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;tip3&#39;</span>
    <span class="n">tips</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">max_d_pairs</span><span class="p">,</span> <span class="n">tip3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">tri_ratio</span> <span class="o">=</span> <span class="n">tips</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;tip3&#39;</span><span class="p">]]</span> <span class="o">+</span> <span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;tip2&#39;</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;tip3&#39;</span><span class="p">]])</span> <span class="o">/</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;tip2&#39;</span><span class="p">]]))</span>

    <span class="c1"># uncomment to get index of observation furthest from observation leading to largest triangular ratio:</span>
    <span class="c1"># root_x = tri_ratio.idxmax()</span>
    <span class="c1"># root_lbl = d.loc[root_x].idxmax()</span>
    <span class="n">root_lbl</span> <span class="o">=</span> <span class="n">tri_ratio</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span> 
    <span class="n">root</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">observation_index</span><span class="p">(</span><span class="n">root_lbl</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span></div>

    
<div class="viewcode-block" id="POSER"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER">[docs]</a><span class="k">class</span> <span class="nc">POSER</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keeper : `netflow.Keeper`</span>
<span class="sd">        The keeper object that stores the distance matrix of size (n_observations, n_observations).</span>
<span class="sd">    key : `str`</span>
<span class="sd">        The label used to reference the distance matrix stored in ``keeper.distances``,</span>
<span class="sd">        of size (n_observations, n_observations).</span>
<span class="sd">    root : {`None`, `int`, &#39;density&#39;, &#39;density_inv&#39;, &#39;ratio&#39;}</span>
<span class="sd">        The root. If `None`, &#39;density&#39; is used.</span>

<span class="sd">        Options:</span>

<span class="sd">        - `int` : index of observation</span>
<span class="sd">        - &#39;density&#39; : select observation with minimal distance-density</span>
<span class="sd">        - &#39;density_inv&#39; : select observation with maximal distance-density</span>
<span class="sd">        - &#39;ratio&#39; : select observation which leads to maximal triangular ratio distance</span>
<span class="sd">    root_as_tip : `bool`</span>
<span class="sd">        If `True`, force first tip as the root.</span>
<span class="sd">        Defaults to `False` following scanpy implementation.</span>
<span class="sd">    min_branch_size : {`int`, `float`}</span>
<span class="sd">        During recursive splitting of branches, only consider splitting a branch with at least</span>
<span class="sd">        ``min_branch_size &gt; 2`` data points.</span>
<span class="sd">        If a `float`, ``min_branch_size`` refers to the fraction of the total number of data points</span>
<span class="sd">        (``0 &lt; min_branch_size &lt; 1``).</span>
<span class="sd">    choose_largest_segment : `bool`</span>
<span class="sd">        If `True`, select largest segment for branching.</span>
<span class="sd">    flavor : {&#39;haghverdi16&#39;, &#39;wolf17_tri&#39;, &#39;wolf17_bi&#39;, &#39;wolf17_bi_un&#39;}</span>
<span class="sd">        Branching algorithm (based on `scanpy` implementation).</span>
<span class="sd">    allow_kendall_tau_shift : `bool`</span>
<span class="sd">        If a very small branch is detected upon splitting, shift away from</span>
<span class="sd">        maximum correlation in Kendall tau criterion of [Haghverdi16]_ to</span>
<span class="sd">        stabilize the splitting.</span>
<span class="sd">    smooth_corr : `bool`, default = `False`</span>
<span class="sd">        If `True`, smooth correlations before identifying cut points for branch splitting.</span>
<span class="sd">    brute : `bool`</span>
<span class="sd">        If `True`, data points not associated with any branch upon split are combined with</span>
<span class="sd">        undecided (trunk) points. Otherwise, if `False`, they are treated as individual islands,</span>
<span class="sd">        not associated with any branch (and assigned branch index -1).</span>
<span class="sd">    split : `bool` (default = True)</span>
<span class="sd">        if `True`, split segment into multiple branches. Otherwise,</span>
<span class="sd">        determine a single branching off of the main segment.</span>
<span class="sd">        This is ignored if flavor is not &#39;haghverdi16&#39;.</span>
<span class="sd">        If `True`, ``brute`` is ignored.</span>
<span class="sd">    connect_closest : `bool` (default = False)</span>
<span class="sd">        If `True`, connect branches by points with smallest distance between the branches.</span>
<span class="sd">        Otherwise, connect by continuum of ordering.</span>
<span class="sd">    connect_trunk : {&#39;classic&#39;, &#39;endpoint&#39;, &#39;dual&#39;}, default = &#39;classic&#39;</span>
<span class="sd">        Specify how to connect segments to unresolved/unidentified trunk.</span>
<span class="sd">        Note, this only applies when a split results in a trunk consisting of unresolved/unidentified points.</span>
<span class="sd">        Additionally, this is ignored if ``flavor ~= &#39;haghverdi16&#39;``.</span>
<span class="sd">        It is also ignored If ``flavor = `haghverdi16&#39;`` and ``split = False``.</span>

<span class="sd">        Options:</span>

<span class="sd">        - `classic` : point identified in trunk is connected to the point in the segment closest to it</span>
<span class="sd">        - `endpoint` : point identified in trunk is connected to the the segment&#39;s second tip</span>
<span class="sd">        - `dual` : point identified in trunk is connected to both points determined by `classic` and `endpoint`</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="POSER.__init__"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keeper</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">root_as_tip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">min_branch_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">choose_largest_segment</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">flavor</span><span class="o">=</span><span class="s1">&#39;haghverdi16&#39;</span><span class="p">,</span> <span class="n">allow_kendall_tau_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">smooth_corr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">brute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">connect_closest</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_trunk</span><span class="o">=</span><span class="s1">&#39;classic&#39;</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">set_verbose</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">distances</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="c1"># self.num_observations = keeper.num_observations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observation_labels</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">observation_labels</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_branch_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">min_branch_size</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;As an integer, `min_branch_size` must be greater than 2.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_min_branch_size</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">min_branch_size</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_branch_size</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">assert</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">min_branch_size</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">,</span> <span class="s2">&quot;As a float, `min_branch_size` must satisfy 0 &lt; `min_branch_size` &lt; 1.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_min_branch_size</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_branch_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unrecognized type for `min_branch_size`, must be an int or float.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_branch_size</span> <span class="o">=</span> <span class="n">min_branch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choose_largest_segment</span> <span class="o">=</span> <span class="n">choose_largest_segment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">=</span> <span class="n">flavor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_kendall_tau_shift</span> <span class="o">=</span> <span class="n">allow_kendall_tau_shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smooth_corr</span> <span class="o">=</span> <span class="n">smooth_corr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">brute</span> <span class="o">=</span> <span class="n">brute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="o">=</span> <span class="n">split</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect_closest</span> <span class="o">=</span> <span class="n">connect_closest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect_trunk</span> <span class="o">=</span> <span class="n">connect_trunk</span>

        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="s2">&quot;density&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="s1">&#39;density&#39;</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">distance_density_argmin</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">root</span> <span class="o">==</span> <span class="s1">&#39;density_inv&#39;</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">distance_density_argmax</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">root</span> <span class="o">==</span> <span class="s1">&#39;ratio&#39;</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root_max_ratio</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized method for determining root, expected to be one of [&#39;density&#39;, &#39;density_inv&#39;, &#39;ratio&#39;].&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">keeper</span><span class="o">.</span><span class="n">num_observations</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized value for root, expected to be the index of an observation in the keeper.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized value for root.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo_dist</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># was pseudotime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_pseudo_dist</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>        
        <span class="c1"># initialize the tree</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">seg</span><span class="p">,</span>
                        <span class="n">nonunique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unidentified</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">branchable</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_min_branch_size</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">is_trunk</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># get tips:</span>
        <span class="c1"># tip_0 = root</span>
        <span class="c1"># get first tip (farthest from root)</span>
        <span class="k">if</span> <span class="n">root_as_tip</span><span class="p">:</span>
            <span class="n">tip_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tip_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">])</span>
        <span class="n">tip_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">tip_0</span><span class="p">])</span>
        <span class="n">node</span><span class="o">.</span><span class="n">tips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tip_0</span><span class="p">,</span> <span class="n">tip_1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branched_ordering</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># [node]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">unidentified_points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span></div>

        
<div class="viewcode-block" id="POSER._set_pseudo_dist"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER._set_pseudo_dist">[docs]</a>    <span class="k">def</span> <span class="nf">_set_pseudo_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return pseudo-distance with respect to root point. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo_dist</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudo_dist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudo_dist</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span></div>

<div class="viewcode-block" id="POSER.select_segment"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER.select_segment">[docs]</a>    <span class="k">def</span> <span class="nf">select_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Select segment with most distant triangulated data point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        node : `TreeNode`</span>
<span class="sd">            The node corresponding to the selected segment.</span>
<span class="sd">            If no nodes are branchable, returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">selected_segs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segs</span><span class="p">):</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">seg</span><span class="o">.</span><span class="n">branchable</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">score</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">selected_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># restrict distance matrix to points in segment</span>
            <span class="n">Dseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">tips</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

                <span class="n">third_maximizer</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">is_trunk</span><span class="p">:</span>
                    <span class="c1"># check that no tip connects with tip of another seg</span>
                    <span class="k">for</span> <span class="n">jseg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">jseg</span> <span class="o">!=</span> <span class="n">iseg</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">itip</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                                <span class="k">if</span> <span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span>
                                            <span class="n">segs</span><span class="p">[</span><span class="n">jseg</span><span class="p">]</span><span class="o">.</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">seg</span><span class="o">.</span><span class="n">tips</span><span class="p">[</span><span class="n">itip</span><span class="p">]</span>
                                        <span class="p">]</span>
                                        <span class="o">&lt;</span> <span class="mf">0.5</span>
                                        <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span>
                                            <span class="n">seg</span><span class="o">.</span><span class="n">tips</span><span class="p">[</span><span class="o">~</span><span class="n">itip</span><span class="p">],</span> <span class="n">seg</span><span class="o">.</span><span class="n">tips</span><span class="p">[</span><span class="n">itip</span><span class="p">]</span>
                                        <span class="p">]</span>
                                <span class="p">):</span>
                                    <span class="n">third_maximizer</span> <span class="o">=</span> <span class="n">itip</span>

                <span class="c1"># map the global position to the position within the segment</span>
                <span class="n">allindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="c1"># find the third point on the seg that has maximal added distance from the two tip points:</span>
                <span class="n">tips</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">allindices</span><span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">data</span><span class="p">]</span> <span class="o">==</span> <span class="n">tip</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tip</span> <span class="ow">in</span> <span class="n">seg</span><span class="o">.</span><span class="n">tips</span><span class="p">]</span> <span class="c1"># local index of tips in the seg</span>
                <span class="c1"># find the third point on the seg that has maximal added distance from the two tip points:</span>
                <span class="n">dseg</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dseg</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">seg</span><span class="o">.</span><span class="n">branchable</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">continue</span>
                <span class="n">third_tip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dseg</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">third_maximizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TODO: THIRD MAXIMIZER IS NOT NONE... IS THIS CORRECT???&quot;</span><span class="p">)</span>
                    <span class="c1"># find a fourth point that has maximal distance to all three</span>
                    <span class="n">dseg</span> <span class="o">+=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">third_tip</span><span class="p">]</span>
                    <span class="n">fourth_tip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dseg</span><span class="p">)</span>
                    <span class="c1"># should it be &gt;&gt;&gt; if fourth_tip != tips[third_maximizer] and fourth_tip != third_tip: ... and &gt;&gt;&gt; tips[third_maximizer] = fourth_tip ???</span>
                    <span class="k">if</span> <span class="n">fourth_tip</span> <span class="o">!=</span> <span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">fourth_tip</span> <span class="o">!=</span> <span class="n">third_tip</span><span class="p">:</span> 
                        <span class="c1"># dseg -= Dseg[tips[1]] # RE CHANGED TO COMPUTE BEFORE UPDATING TIP</span>
                        <span class="c1"># logger.msg(f&quot;TODO: tip1 changed from {tips[1]} to {fourth_tip}...&quot;)</span>
                        <span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fourth_tip</span>
                        <span class="n">dseg</span> <span class="o">-=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1"># OLD WAY COMPUTED AFTER UPDATING TIP --- should it be dseg += Dseg[tips[1]]?</span>
                        <span class="c1"># dseg = Dseg[tips[0]] + Dseg[tips[1]] # RE ADDED SECOND NEW WAY OPTION:</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dseg</span> <span class="o">-=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">third_tip</span><span class="p">]</span>
                <span class="n">tips3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tips</span><span class="p">,</span> <span class="n">third_tip</span><span class="p">)</span>

                <span class="c1"># update third tip in global coordinates NOTE: double check that this is correct</span>
                <span class="c1"># seg.tips.append(seg.data[third_tip])</span>
                <span class="c1"># seg.tips = np.append(seg.tips, seg.data[third_tip])</span>
                <span class="n">seg</span><span class="o">.</span><span class="n">tips</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">tips3</span><span class="p">]</span>
                
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">tips</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># map the global position to the position within the segment</span>
                <span class="n">allindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="c1"># find the third point on the seg that has maximal added distance from the two tip points:</span>
                <span class="n">tips3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">allindices</span><span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">data</span><span class="p">]</span> <span class="o">==</span> <span class="n">tip</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tip</span> <span class="ow">in</span> <span class="n">seg</span><span class="o">.</span><span class="n">tips</span><span class="p">])</span> <span class="c1"># local index of tips in the seg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Unexpected number of tips.&quot;</span><span class="p">)</span>
            
            <span class="c1"># compute the score as ratio of the added distance to the third tip,</span>
            <span class="c1"># to what it would be if it were on the straight line between the</span>
            <span class="c1"># two first tips, given by Dseg[tips[:2]]</span>
            <span class="c1"># if we did not normalize, there would be a danger of simply</span>
            <span class="c1"># assigning the highest score to the longest segment</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">dseg</span><span class="p">[</span><span class="n">tips3</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">/</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tips3</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">score</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_largest_segment</span> <span class="k">else</span> <span class="n">score</span> <span class="c1"># simply the number of points</span>
            <span class="n">seg</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">score</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_min_branch_size</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
                <span class="n">seg</span><span class="o">.</span><span class="n">branchable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selected_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_segs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">selected_seg</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">selected_segs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">score</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selected_seg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">selected_seg</span></div>


<div class="viewcode-block" id="POSER._kendall_tau_add"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER._kendall_tau_add">[docs]</a>    <span class="k">def</span> <span class="nf">_kendall_tau_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">len_old</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">diff_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tau_old</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute Kendall tau delta.</span>

<span class="sd">        The new sequence has length len_old + 1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        len_old</span>
<span class="sd">            The length of the old sequence, used to compute tau_old.</span>
<span class="sd">        diff_pos</span>
<span class="sd">            Difference between concordant and non-concordant pairs.</span>
<span class="sd">        tau_old</span>
<span class="sd">            Kendall rank correlation of the old sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">len_old</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">diff_pos</span><span class="p">)</span> <span class="o">/</span> <span class="n">len_old</span> <span class="o">-</span> <span class="n">tau_old</span><span class="p">)</span></div>


<div class="viewcode-block" id="POSER._kendall_tau_subtract"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER._kendall_tau_subtract">[docs]</a>    <span class="k">def</span> <span class="nf">_kendall_tau_subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">len_old</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">diff_neg</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tau_old</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute Kendall tau delta.</span>

<span class="sd">        The new sequence has length len_old - 1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        len_old</span>
<span class="sd">            The length of the old sequence, used to compute tau_old.</span>
<span class="sd">        diff_neg</span>
<span class="sd">            Difference between concordant and non-concordant pairs.</span>
<span class="sd">        tau_old</span>
<span class="sd">            Kendall rank correlation of the old sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">len_old</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">diff_neg</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">len_old</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau_old</span><span class="p">)</span></div>


<div class="viewcode-block" id="POSER._kendall_tau_diff"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER._kendall_tau_diff">[docs]</a>    <span class="k">def</span> <span class="nf">_kendall_tau_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute difference in concordance of pairs in split sequences.</span>

<span class="sd">        Consider splitting a and b at index i.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a, b : `numpy.ndarray`</span>
<span class="sd">            One dimensional sequences.</span>
<span class="sd">        i : `int`</span>
<span class="sd">            Index for splitting ``a`` and ``b``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        diff_pos</span>
<span class="sd">            Difference between concordant pairs for both subsequences.</span>
<span class="sd">        diff_neg</span>
<span class="sd">            Difference between non-concordant pairs for both subsequences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute ordering relation of the single points a[i] and b[i]</span>
        <span class="c1"># with all previous points of the sequences a and b, respectively</span>
        <span class="n">a_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">a_pos</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">a_pos</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">b_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">b_pos</span><span class="p">[</span><span class="n">b</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">b_pos</span><span class="p">[</span><span class="n">b</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">diff_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a_pos</span><span class="p">,</span> <span class="n">b_pos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># compute ordering relation of the single points a[i] and b[i]</span>
        <span class="c1"># with all later points of the sequences</span>
        <span class="n">a_neg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">a_neg</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">a_neg</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">b_neg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">b_neg</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">b_neg</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">diff_neg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a_neg</span><span class="p">,</span> <span class="n">b_neg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">diff_pos</span><span class="p">,</span> <span class="n">diff_neg</span></div>

    
<div class="viewcode-block" id="POSER.kendall_tau_split"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER.kendall_tau_split">[docs]</a>    <span class="k">def</span> <span class="nf">kendall_tau_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>  <span class="n">min_length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return splitting index that maximizes correlation in the sequences.</span>

<span class="sd">        Compute difference in Kendall tau for all splitted sequences.</span>

<span class="sd">        For each splitting index i, compute the difference of the two</span>
<span class="sd">        correlation measures kendalltau(a[:i], b[:i]) and</span>
<span class="sd">        kendalltau(a[i:], b[i:]).</span>

<span class="sd">        Returns the splitting index that maximizes</span>
<span class="sd">            kendalltau(a[:i], b[:i]) - kendalltau(a[i:], b[i:])</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a, b : `numpy.ndarray`</span>
<span class="sd">            One dimensional sequences.</span>
<span class="sd">        min_length : `int`, (``min_length &gt; 0``)</span>
<span class="sd">            Minimum number of data points automatically included in branch.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        imax : `int`</span>
<span class="sd">            Splitting index according to above description.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;a and b need to have the same size&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;a and b need to be one-dimensional arrays&#39;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
        <span class="n">idx_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_length</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">min_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">corr_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">idx_range</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">pos_old</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="n">min_length</span><span class="p">],</span> <span class="n">b</span><span class="p">[:</span><span class="n">min_length</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">neg_old</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">min_length</span><span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="n">min_length</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_range</span><span class="p">):</span>
            <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># compute differences in concordance when adding a[i] and b[i]</span>
                <span class="c1"># to the first subsequence, and removing these elements from</span>
                <span class="c1"># the second subsequence</span>
                <span class="n">diff_pos</span><span class="p">,</span> <span class="n">diff_neg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kendall_tau_diff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">pos_old</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kendall_tau_add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">diff_pos</span><span class="p">,</span> <span class="n">pos_old</span><span class="p">)</span>
                <span class="n">neg</span> <span class="o">=</span> <span class="n">neg_old</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kendall_tau_subtract</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">diff_neg</span><span class="p">,</span> <span class="n">neg_old</span><span class="p">)</span>
                <span class="n">pos_old</span> <span class="o">=</span> <span class="n">pos</span>
                <span class="n">neg_old</span> <span class="o">=</span> <span class="n">neg</span>
            <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># computation using sp.stats.kendalltau, takes much longer!</span>
                <span class="c1"># just for debugging purposes</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">neg</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># the following is much slower than using sp.stats.kendalltau,</span>
                <span class="c1"># it is only good for debugging because it allows to compute the</span>
                <span class="c1"># tau-a version, which does not account for ties, whereas</span>
                <span class="c1"># sp.stats.kendalltau computes tau-b version, which accounts for</span>
                <span class="c1"># ties</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">use_ties</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">neg</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">use_ties</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">corr_coeff</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">neg</span>
            <span class="c1"># logger.warning(f&quot;*corr_coeff = {corr_coeff}, corr_coeff[{ii}] = {pos - neg}&quot;)</span>
        <span class="c1"># RE START MODIFIED</span>
        <span class="c1"># iimax = np.argmax(corr_coeff)</span>
        <span class="c1"># imax = min_length + iimax</span>
        <span class="c1"># corr_coeff_max = corr_coeff[iimax]</span>

        <span class="c1"># TODO: add smoothing to corr_coeff before selecting max index</span>
        <span class="k">if</span> <span class="n">corr_coeff</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iimax</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">corr_coeff_max</span> <span class="o">=</span> <span class="mf">0.</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_corr</span><span class="p">:</span>
                <span class="c1"># logger.msg(f&quot;corr before smoothing: {corr_coeff}&quot;)</span>
                <span class="c1"># logger.msg(f&quot;imax before smoothing: {np.argmax(corr_coeff)}&quot;)</span>
                <span class="n">corr_coeff</span> <span class="o">=</span> <span class="n">utl</span><span class="o">.</span><span class="n">gauss_conv</span><span class="p">(</span><span class="n">corr_coeff</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">smoothness</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>
                <span class="c1"># logger.msg(f&quot;corr after smoothing: {corr_coeff}&quot;)</span>
                <span class="c1"># logger.msg(f&quot;imax after smoothing: {np.argmax(corr_coeff)}&quot;)</span>

            <span class="n">iimax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">corr_coeff</span><span class="p">)</span>
            <span class="n">corr_coeff_max</span> <span class="o">=</span> <span class="n">corr_coeff</span><span class="p">[</span><span class="n">iimax</span><span class="p">]</span>                
            
        <span class="c1"># iimax = 0 if corr_coeff.size == 0 else np.argmax(corr_coeff)</span>
        <span class="n">imax</span> <span class="o">=</span> <span class="n">min_length</span> <span class="o">+</span> <span class="n">iimax</span>
        <span class="c1"># corr_coeff_max = 0. if corr_coeff.size == 0 else corr_coeff[iimax]</span>
        
        <span class="c1"># RE END MODIFIED</span>
        <span class="k">if</span> <span class="n">corr_coeff_max</span> <span class="o">&lt;</span> <span class="mf">0.3</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;    is root itself, never obtain significant correlation&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">imax</span></div>


    <span class="k">def</span> <span class="nf">__detect_branching_haghverdi16</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tips</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect branching on given segment.</span>

<span class="sd">        Compute point that maximizes kendall tau correlation of the sequences of</span>
<span class="sd">        distances to the second and the third tip, respectively, when &#39;moving</span>
<span class="sd">        away&#39; from the first tip: tips[0]. &#39;Moving away&#39; means moving in the</span>
<span class="sd">        direction of increasing distance from the first tip.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Dseg</span>
<span class="sd">            The distance matrix restricted to segment.</span>
<span class="sd">        tips</span>
<span class="sd">            The three tip points in local coordinates to the segment.</span>
<span class="sd">            They form a &#39;triangle&#39; that contains the data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        branch : `numpy.ndarray` (k,)</span>
<span class="sd">            Segment obtained from &quot;splitting away the first tip data point&quot;,</span>
<span class="sd">            where k is the number of data points in the branch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sort distance from first tip point</span>
        <span class="c1"># then the sequence of distances Dseg[tips[0]][idcs] increases</span>
        <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kendall_tau_split</span><span class="p">(</span>
                <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">idcs</span><span class="p">],</span>
                <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">idcs</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># if we were in euclidian space, the following should work</span>
            <span class="c1"># as well, but here, it doesn&#39;t because the scales in Dseg are</span>
            <span class="c1"># highly different, one would need to write the following equation</span>
            <span class="c1"># in terms of an ordering, such as exploited by the kendall</span>
            <span class="c1"># correlation method above</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">idcs</span><span class="p">]</span> <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">idcs</span><span class="p">]</span> <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">idcs</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># first new segment: all points until, but excluding the branching point</span>
        <span class="c1"># increasing the following slightly from imax is a more conservative choice</span>
        <span class="c1"># as the criterion based on normalized distances, which follows below,</span>
        <span class="c1"># is less stable</span>
        <span class="k">if</span> <span class="n">imax</span> <span class="o">&gt;</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">idcs</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;segment is more than 95\</span><span class="si">% c</span><span class="s1">orrelated.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">imax</span> <span class="o">&gt;</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">idcs</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_kendall_tau_shift</span><span class="p">:</span>            
            <span class="c1"># if &quot;everything&quot; is correlated (very large value of imax), a more</span>
            <span class="c1"># conservative choice amounts to reducing this</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;shifting branching point away from maximal kendall-tau &#39;</span>
                <span class="s1">&#39;correlation (suppress this with `allow_kendall_tau_shift=False`)&#39;</span>
            <span class="p">)</span>
            <span class="n">ibranch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.95</span> <span class="o">*</span> <span class="n">imax</span><span class="p">)</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># otherwise, a more conservative choice is the following</span>
            <span class="n">ibranch</span> <span class="o">=</span> <span class="n">imax</span> <span class="o">+</span> <span class="mi">1</span>

            
        <span class="n">branch</span> <span class="o">=</span> <span class="n">idcs</span><span class="p">[:</span><span class="n">ibranch</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">branch</span>
        
        
<div class="viewcode-block" id="POSER._detect_branching_single_haghverdi16"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER._detect_branching_single_haghverdi16">[docs]</a>    <span class="k">def</span> <span class="nf">_detect_branching_single_haghverdi16</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tips</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detect branching on given segment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Dseg</span>
<span class="sd">        tips</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ssegs : `list[numpy.ndarray]`</span>
<span class="sd">            The branched segments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute branchings using different starting points the first index of</span>
        <span class="c1"># tips is the starting point for the other two, the order does not</span>
        <span class="c1"># matter</span>
        <span class="n">ssegs</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="c1"># permutations of tip cells</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">:</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  <span class="c1"># start by computing distances from the first tip</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1">#             -&quot;-                       second tip</span>
                <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1">#             -&quot;-                       third tip</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ps = [[2, 0, 1]]</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ps</span><span class="p">):</span>
            <span class="c1"># logger.warning(f&quot;*iterating p: i = {i}&quot;)</span>
            <span class="n">ssegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__detect_branching_haghverdi16</span><span class="p">(</span><span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">[</span><span class="n">p</span><span class="p">]))</span>

        
        <span class="c1"># if not self.split:</span>
        <span class="c1">#     # add main portion of branch</span>
        <span class="c1">#     ssegs.append(list(set(range(Dseg.shape[0])) - set(ssegs[0])))</span>
            
        <span class="k">return</span> <span class="n">ssegs</span></div>


<div class="viewcode-block" id="POSER._detect_branching_single_wolf17_tri"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER._detect_branching_single_wolf17_tri">[docs]</a>    <span class="k">def</span> <span class="nf">_detect_branching_single_wolf17_tri</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">):</span>
        <span class="c1"># all pairwise distances</span>
        <span class="n">dist_from_0</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">dist_from_1</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">dist_from_2</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">closer_to_0_than_to_1</span> <span class="o">=</span> <span class="n">dist_from_0</span> <span class="o">&lt;</span> <span class="n">dist_from_1</span>
        <span class="n">closer_to_0_than_to_2</span> <span class="o">=</span> <span class="n">dist_from_0</span> <span class="o">&lt;</span> <span class="n">dist_from_2</span>
        <span class="n">closer_to_1_than_to_2</span> <span class="o">=</span> <span class="n">dist_from_1</span> <span class="o">&lt;</span> <span class="n">dist_from_2</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">closer_to_0_than_to_1</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">closer_to_0_than_to_2</span>
        <span class="n">segment_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">closer_to_0_than_to_1</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">closer_to_1_than_to_2</span>
        <span class="n">segment_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">closer_to_0_than_to_2</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">closer_to_1_than_to_2</span>
        <span class="n">segment_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">ssegs</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment_0</span><span class="p">,</span> <span class="n">segment_1</span><span class="p">,</span> <span class="n">segment_2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ssegs</span></div>


<div class="viewcode-block" id="POSER._detect_branching_single_wolf17_bi"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER._detect_branching_single_wolf17_bi">[docs]</a>    <span class="k">def</span> <span class="nf">_detect_branching_single_wolf17_bi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">):</span>
        <span class="n">dist_from_0</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">dist_from_1</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">closer_to_0_than_to_1</span> <span class="o">=</span> <span class="n">dist_from_0</span> <span class="o">&lt;</span> <span class="n">dist_from_1</span>
        <span class="n">ssegs</span> <span class="o">=</span> <span class="p">[</span><span class="n">closer_to_0_than_to_1</span><span class="p">,</span> <span class="o">~</span><span class="n">closer_to_0_than_to_1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ssegs</span></div>
    

<div class="viewcode-block" id="POSER._detect_branch"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER._detect_branch">[docs]</a>    <span class="k">def</span> <span class="nf">_detect_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tips</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1"># , connect_closest=False):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Detect branching on given segment.</span>

<span class="sd">        If ``self.split``, Call function __detect_branching three times for all three orderings </span>
<span class="sd">        of tips. Points that do not belong to the same segment in all three</span>
<span class="sd">        orderings are assigned to a fourth segment. The latter is, by Haghverdi</span>
<span class="sd">        et al. (2016) referred to as &#39;undecided points&#39; (which make up the so-called &#39;trunk&#39;).</span>
<span class="sd">        Otherwise, only the branch off the main segment is detected from the third tip.</span>


<span class="sd">        If ``split`` and ``flavor == &#39;haghverdi16&#39;`` : If any of the branches from the three</span>
<span class="sd">        consist of zero unique observations, resulting in an empty branch, the process is</span>
<span class="sd">        terminated and no branching is performed on the current segment.</span>

<span class="sd">        ..note::</span>
<span class="sd">        </span>
<span class="sd">          In practice, this has only occurred in small segments. If finer resolution partitioning</span>
<span class="sd">          is desired, this may be changed in a future release to account for an offshoot resulting</span>
<span class="sd">          in two branches (and possibly a trunk with undecided points). </span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Dseg</span>
<span class="sd">            The distance matrix restricted to segment.</span>
<span class="sd">        tips : `numpy.ndarray`</span>
<span class="sd">            Tips in local coordinates relative to the segment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ssegs : list[list]</span>
<span class="sd">            Stores branched segments in local coordinates.</span>
<span class="sd">        ssegs_tips : list[list]</span>
<span class="sd">            Stores all tip points in local coordinates for the segments in ``ssegs``.</span>
<span class="sd">        ssegs_connects list[list]</span>
<span class="sd">            A list of k lists, where k is the number of inter-segment connections between</span>
<span class="sd">            the segments in ``ssegs``. Each entry is a 2-list of the form</span>
<span class="sd">            [[index of first seg in ``ssegs``, index of second seg in ``ssegs``], </span>
<span class="sd">            [source observation, target observation]].</span>
<span class="sd">        trunk : `int`</span>
<span class="sd">            Index of segment in `ssegs` that all other segments in ``ssegs`` stem from.</span>
<span class="sd">        trunk_undecided : `bool`</span>
<span class="sd">            If True, the trunk are made up of undecided points.</span>
<span class="sd">        unidentified_points : `set`            </span>
<span class="sd">            Points in local coordinates relative to the segment before branching</span>
<span class="sd">            that are not associated with any branch after splitting.        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">==</span> <span class="s1">&#39;haghverdi16&#39;</span><span class="p">:</span>
            <span class="n">ssegs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_branching_single_haghverdi16</span><span class="p">(</span><span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">)</span>  <span class="c1"># correlation</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">==</span> <span class="s1">&#39;wolf17_tri&#39;</span><span class="p">:</span>
            <span class="n">ssegs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_branching_single_wolf17_tri</span><span class="p">(</span><span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">)</span>  <span class="c1"># closer in distance to tip than other two tips</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">==</span> <span class="s1">&#39;wolf17_bi&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">==</span> <span class="s1">&#39;wolf17_bi_un&#39;</span><span class="p">:</span> 
            <span class="n">ssegs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_branching_single_wolf17_bi</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;`flavor` needs to be in {&quot;haghverdi16&quot;, &quot;wolf17_tri&quot;, &quot;wolf17_bi, &quot;wolf17_bi_un&quot;&quot;}.&#39;</span>
            <span class="p">)</span>
        
        <span class="n">trunk_undecided</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">!=</span> <span class="s1">&#39;haghverdi16&#39;</span><span class="p">):</span>
            <span class="c1"># make sure that each data point has a unique association with a segment</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ssegs</span><span class="p">),</span> <span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs</span><span class="p">):</span>
                <span class="n">masks</span><span class="p">[</span><span class="n">iseg</span><span class="p">][</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>                
            <span class="n">nonunique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;* </span><span class="si">{</span><span class="n">nonunique</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2"> nonunique points.&quot;</span><span class="p">)</span>

            <span class="c1"># RE START MODIFIED - to account for points not associated with any branch</span>
            <span class="n">unidentified</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;* </span><span class="si">{</span><span class="n">unidentified</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2"> unidentified points.&quot;</span><span class="p">)</span>        
            <span class="c1"># RE END MODIFIED</span>

            <span class="c1"># RE START MODIFIED - uncomment to match how original paper defines unique</span>
            <span class="c1"># if len(ssegs) == 3:</span>
            <span class="c1">#     allbranches = np.sum(masks, axis=0) == len(ssegs)</span>
            <span class="c1">#     twobranches = np.sum(masks[1:, :], axis=0) == len(ssegs) - 1</span>
            <span class="c1">#     nonunique = allbranches | twobranches</span>
            <span class="c1"># else:</span>
            <span class="c1">#     nonunique = np.sum(masks, axis=0) &gt; 1</span>
            <span class="c1"># # RE END MODIFIED</span>
            <span class="n">ssegs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">nonunique</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># RE START MODIFIED  - IN EVENT THAT THE SEG HAD NO UNIQUE MEMBERS AND IS NOW EMPTY:</span>
                <span class="c1"># ssegs.append(np.arange(Dseg.shape[0], dtype=int)[mask])</span>

                <span class="n">newseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">newseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># logger.debug(&quot;Unique segment is empty, continuing branching without it.&quot;)</span>
                    <span class="c1"># continue # TODO - future release switch return to continue for finer resolution partitioning</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Unique segment is empty, removing from consideration and no branching performed.&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">None</span>

                <span class="n">ssegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newseg</span><span class="p">)</span>
                <span class="c1"># RE END MODIFIED</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssegs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># RE MODIFIED HERE</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># compute new tips within new segments (relative to the full segment)</span>
            <span class="n">ssegs_tips</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">newseg</span><span class="p">,</span> <span class="n">tip</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ssegs</span><span class="p">,</span> <span class="n">tips</span><span class="p">):</span>
                <span class="c1"># logger.warning(f&quot;*** tip = {tip}&quot;)</span>
                <span class="n">newseg_tips</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_local_tips</span><span class="p">(</span><span class="n">Dseg</span><span class="p">,</span> <span class="n">newseg</span><span class="p">,</span> <span class="n">tip</span><span class="p">)</span>                
                <span class="n">ssegs_tips</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newseg_tips</span><span class="p">)</span>

            <span class="c1"># RE MODIFIED END</span>

            <span class="c1"># RE START MODIFIED - to account for points not associated with any branch</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">brute</span><span class="p">:</span>
                <span class="n">nonunique</span> <span class="o">=</span> <span class="n">nonunique</span> <span class="o">|</span> <span class="n">unidentified</span>
            <span class="c1"># RE END MODIFIED</span>
            <span class="n">undecided_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="n">nonunique</span><span class="p">]</span>

            <span class="c1"># RE START MODIFIED - to account for points not associated with any branch</span>
            <span class="n">unidentified_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="n">unidentified</span><span class="p">]</span>
            <span class="c1"># RE END MODIFIED</span>

            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">undecided_cells</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ssegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">undecided_cells</span><span class="p">)</span>
                <span class="n">trunk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssegs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">trunk_undecided</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># establish the connecting points with the other segments</span>
                <span class="n">ssegs_connects</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># [[]]*len(ssegs) # [[], [], [], []]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_closest</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i_cur_seg</span><span class="p">,</span> <span class="n">cur_seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                         <span class="n">dseg_cur</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">cur_seg</span><span class="p">,</span> <span class="n">ssegs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
                         <span class="n">point_in_seg</span><span class="p">,</span> <span class="n">point_in_trunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dseg_cur</span><span class="p">),</span> <span class="n">dseg_cur</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                         <span class="n">ssegs_connects</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">trunk</span><span class="p">,</span> <span class="n">i_cur_seg</span><span class="p">],</span> <span class="p">[</span><span class="n">undecided_cells</span><span class="p">[</span><span class="n">point_in_trunk</span><span class="p">],</span>
                                                                     <span class="n">cur_seg</span><span class="p">[</span><span class="n">point_in_seg</span><span class="p">]]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">inewseg</span><span class="p">,</span> <span class="n">newseg_tips</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs_tips</span><span class="p">):</span>
                        <span class="n">reference_point</span> <span class="o">=</span> <span class="n">newseg_tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1"># closest (undecided) cell to the new segment tip within undecided cells</span>
                        <span class="n">closest_cell_a</span> <span class="o">=</span> <span class="n">undecided_cells</span><span class="p">[</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">][</span><span class="n">undecided_cells</span><span class="p">])</span>
                        <span class="p">]</span>
                        <span class="c1"># RE START MODIFIED</span>
                        <span class="c1"># # ssegs_connects[inewseg].append(closest_cell)</span>
                        <span class="c1"># ssegs_connects[-1].append(closest_cell_a)</span>
                        <span class="c1"># RE END MODIFIED</span>
                        <span class="c1"># closest cell to the undecided cells within new segment</span>
                        <span class="n">closest_cell_b</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="n">inewseg</span><span class="p">][</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">closest_cell_a</span><span class="p">][</span><span class="n">ssegs</span><span class="p">[</span><span class="n">inewseg</span><span class="p">]])</span>
                        <span class="p">]</span>
                        <span class="c1"># RE START MODIFIED</span>
                        <span class="c1"># # ssegs_connects[-1].append(closest_cell)</span>
                        <span class="c1"># ssegs_connects[inewseg].append(closest_cell)</span>
                        <span class="c1"># RE END MODIFIED</span>

                        <span class="c1"># TESTING HERE!!!</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_trunk</span> <span class="o">==</span> <span class="s1">&#39;classic&#39;</span><span class="p">:</span>
                            <span class="c1"># trunk is connected to point in seg closest to the selected trunk point</span>
                            <span class="n">ssegs_connects</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">trunk</span><span class="p">,</span> <span class="n">inewseg</span><span class="p">],</span> <span class="p">[</span><span class="n">closest_cell_a</span><span class="p">,</span> <span class="n">closest_cell_b</span><span class="p">]])</span>
                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_trunk</span> <span class="o">==</span> <span class="s1">&#39;endpoint&#39;</span><span class="p">:</span>
                            <span class="c1"># (new) trunk is connected to seg endpoint</span>
                            <span class="n">ssegs_connects</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">trunk</span><span class="p">,</span> <span class="n">inewseg</span><span class="p">],</span> <span class="p">[</span><span class="n">closest_cell_a</span><span class="p">,</span> <span class="n">newseg_tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_trunk</span> <span class="o">==</span> <span class="s1">&#39;dual&#39;</span><span class="p">:</span>
                            <span class="c1"># trunk is connected two places in seg according to &#39;classic&#39; and &#39;endpoint&#39;</span>
                            <span class="n">ssegs_connects</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">trunk</span><span class="p">,</span> <span class="n">inewseg</span><span class="p">],</span> <span class="p">[</span><span class="n">closest_cell_a</span><span class="p">,</span> <span class="n">closest_cell_b</span><span class="p">]])</span>
                            <span class="k">if</span> <span class="n">closest_cell_b</span> <span class="o">!=</span> <span class="n">newseg_tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="n">ssegs_connects</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">trunk</span><span class="p">,</span> <span class="n">inewseg</span><span class="p">],</span> <span class="p">[</span><span class="n">closest_cell_a</span><span class="p">,</span> <span class="n">newseg_tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected value for ``connect_trunk``, must be one of [&#39;classic&#39;, &#39;endpoint&#39;, &#39;dual&#39;]&quot;</span><span class="p">)</span>

                <span class="c1"># also compute tips for the undecided cells</span>
                <span class="n">tip_0</span> <span class="o">=</span> <span class="n">undecided_cells</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">undecided_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">undecided_cells</span><span class="p">])</span>
                <span class="p">]</span>

                <span class="n">tip_1</span> <span class="o">=</span> <span class="n">undecided_cells</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">tip_0</span><span class="p">][</span><span class="n">undecided_cells</span><span class="p">])]</span>
                <span class="n">ssegs_tips</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tip_0</span><span class="p">,</span> <span class="n">tip_1</span><span class="p">])</span>
                <span class="c1"># RE START MODIFIED</span>
                <span class="c1"># trunk = 3</span>
                <span class="c1"># trunk = len(ssegs) - 1</span>
                <span class="c1"># logger.warning(f&quot;trunk = {trunk}&quot;)</span>
                <span class="c1"># RE END MODIFIED</span>
                <span class="c1"># ssegs_adjacency = [[trunk]]*trunk + [list(range(trunk))] # [[3], [3], [3], [0, 1, 2]]</span>
                
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssegs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">reference_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">reference_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs_tips</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">reference_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs_tips</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">reference_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs_tips</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">closest_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_closest</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">seg_a</span><span class="p">,</span> <span class="n">seg_b</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>                        
                        <span class="c1"># i_cur_seg, cur_seg in enumerate(ssegs[:-1]):</span>
                         <span class="n">dseg_cur</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">ssegs</span><span class="p">[</span><span class="n">seg_a</span><span class="p">],</span> <span class="n">ssegs</span><span class="p">[</span><span class="n">seg_b</span><span class="p">])]</span>
                         <span class="n">point_in_seg_a</span><span class="p">,</span> <span class="n">point_in_seg_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dseg_cur</span><span class="p">),</span> <span class="n">dseg_cur</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                         <span class="n">closest_points</span><span class="p">[</span><span class="n">seg_a</span><span class="p">,</span> <span class="n">seg_b</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="n">seg_b</span><span class="p">][</span><span class="n">point_in_seg_b</span><span class="p">]</span>
                         <span class="n">closest_points</span><span class="p">[</span><span class="n">seg_b</span><span class="p">,</span> <span class="n">seg_a</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="n">seg_a</span><span class="p">][</span><span class="n">point_in_seg_a</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># this is another strategy than for the undecided_cells</span>
                    <span class="c1"># here it&#39;s possible to use the more symmetric procedure</span>
                    <span class="c1"># shouldn&#39;t make much of a difference</span>
                    <span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="p">]</span>
                    <span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="p">]</span>
                    <span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
                    <span class="p">]</span>
                    <span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="p">]</span>
                    <span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
                    <span class="p">]</span>
                    <span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="p">]</span>

                <span class="n">added_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">added_dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                    <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
                <span class="p">)</span>

                <span class="n">added_dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                    <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
                <span class="p">)</span>

                <span class="n">added_dist</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                    <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                <span class="p">)</span>

                <span class="n">trunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">added_dist</span><span class="p">)</span>
                <span class="c1"># ssegs_adjacency = [</span>
                <span class="c1">#     [trunk] if i != trunk else [j for j in range(3) if j != trunk]</span>
                <span class="c1">#     for i in range(3)</span>
                <span class="c1"># ]</span>

                <span class="c1"># RE START MODIFIED</span>
                <span class="c1"># # ssegs_connects = [</span>
                <span class="c1"># #     [closest_points[i, trunk]]</span>
                <span class="c1"># #     if i != trunk</span>
                <span class="c1"># #     else [closest_points[trunk, j] for j in range(3) if j != trunk]</span>
                <span class="c1"># #     for i in range(3)</span>
                <span class="c1"># # ]</span>
                <span class="c1"># ssegs_connects = [</span>
                <span class="c1">#     [closest_points[trunk, i]]</span>
                <span class="c1">#     if i != trunk</span>
                <span class="c1">#     else [closest_points[j, trunk] for j in range(3) if j != trunk]</span>
                <span class="c1">#     for i in range(3)</span>
                <span class="c1"># ]</span>
                <span class="n">ssegs_connects</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">trunk</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                                   <span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="n">trunk</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                                    <span class="n">closest_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">trunk</span><span class="p">]]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">trunk</span><span class="p">]</span>

                <span class="c1"># RE END MODIFIED</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">trunk</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># ssegs_adjacency = [[1], [0]]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_closest</span><span class="p">:</span>
                    <span class="n">dseg_cur</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="n">point_in_seg_0</span><span class="p">,</span> <span class="n">point_in_seg_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dseg_cur</span><span class="p">),</span> <span class="n">dseg_cur</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">ssegs_connects</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">point_in_seg_1</span><span class="p">],</span>
                                                <span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">point_in_seg_0</span><span class="p">]]]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">reference_point_in_0</span> <span class="o">=</span> <span class="n">ssegs_tips</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">closest_point_in_1</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point_in_0</span><span class="p">][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="p">]</span>
                    <span class="n">reference_point_in_1</span> <span class="o">=</span> <span class="n">closest_point_in_1</span>  <span class="c1"># ssegs_tips[1][0]</span>
                    <span class="n">closest_point_in_0</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point_in_1</span><span class="p">][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="p">]</span>
                    <span class="c1"># RE START MODIFIED</span>
                    <span class="c1"># # ssegs_connects = [[closest_point_in_1], [closest_point_in_0]]</span>
                    <span class="c1"># ssegs_connects = [[closest_point_in_0], [closest_point_in_1]]</span>
                    <span class="n">ssegs_connects</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">closest_point_in_0</span><span class="p">,</span> <span class="n">closest_point_in_1</span><span class="p">]]]</span>
                    <span class="c1"># RE END MODIFIED</span>
                                      

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssegs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
                
            <span class="n">branch_seg</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">main_seg</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">branch_seg</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_seg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">ssegs</span> <span class="o">=</span> <span class="p">[</span><span class="n">main_seg</span><span class="p">,</span> <span class="n">branch_seg</span><span class="p">]</span>

            <span class="c1"># compute new tips within new segments</span>
            <span class="c1"># ssegs_tips = [list(tips[:2])]</span>
            <span class="c1"># branch_tips = self.identify_local_tips(Dseg, branch_seg, tips[2])</span>
            <span class="c1"># ssegs_tips.append(branch_tips)</span>
            <span class="n">ssegs_tips</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">identify_local_tips</span><span class="p">(</span><span class="n">Dseg</span><span class="p">,</span>
                                                   <span class="n">ss</span><span class="p">,</span>
                                                   <span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">tt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">main_seg</span><span class="p">,</span>
                                                                          <span class="n">branch_seg</span><span class="p">],</span>
                                                                         <span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                          <span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="c1"># tips[2],</span>
                                                                          <span class="p">])]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_closest</span><span class="p">:</span>
                <span class="n">dseg_cur</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">branch_seg</span><span class="p">,</span> <span class="n">main_seg</span><span class="p">)]</span>
                <span class="n">point_in_branch_seg</span><span class="p">,</span> <span class="n">point_in_main_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dseg_cur</span><span class="p">),</span> <span class="n">dseg_cur</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">closest_cell_a</span> <span class="o">=</span> <span class="n">branch_seg</span><span class="p">[</span><span class="n">point_in_branch_seg</span><span class="p">]</span>
                <span class="n">closest_cell_b</span> <span class="o">=</span> <span class="n">main_seg</span><span class="p">[</span><span class="n">point_in_main_seg</span><span class="p">]</span>

                <span class="n">trunk</span><span class="o">=</span><span class="mi">0</span>
                <span class="n">ssegs_connects</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">closest_cell_a</span><span class="p">,</span>
                                            <span class="n">closest_cell_b</span><span class="p">]]]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># ssegs_connects = [[]]*len(ssegs) # [[], []]</span>
                <span class="c1"># point in branch closest to the main segment</span>
                <span class="n">reference_point</span> <span class="o">=</span> <span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">closest_cell_a</span> <span class="o">=</span> <span class="n">branch_seg</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">][</span><span class="n">branch_seg</span><span class="p">])</span>
                <span class="p">]</span>
                <span class="c1"># RE START MODIFIED</span>
                <span class="c1"># # ssegs_connects[0].append(closest_cell)</span>
                <span class="c1"># ssegs_connects[-1].append(closest_cell_a)</span>
                <span class="c1"># RE END MODIFIED</span>
                <span class="c1"># point in main segment closest to the identified branch point</span>
                <span class="n">closest_cell_b</span> <span class="o">=</span> <span class="n">main_seg</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">closest_cell_a</span><span class="p">][</span><span class="n">main_seg</span><span class="p">])</span>
                <span class="p">]</span>
                <span class="c1"># RE START MODIFIED</span>
                <span class="c1"># # ssegs_connects[-1].append(closest_cell)</span>
                <span class="c1"># ssegs_connects[0].append(closest_cell_b)</span>
                <span class="c1"># RE END MODIFIED</span>

                <span class="n">trunk</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># ssegs_adjacency = [[1], [0]]</span>
                <span class="n">ssegs_connects</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">closest_cell_a</span><span class="p">,</span> <span class="n">closest_cell_b</span><span class="p">]]]</span>

            <span class="n">unidentified_points</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># return ssegs, ssegs_tips, ssegs_adjacency, ssegs_connects, \</span>
        <span class="k">return</span> <span class="n">ssegs</span><span class="p">,</span> <span class="n">ssegs_tips</span><span class="p">,</span> <span class="n">ssegs_connects</span><span class="p">,</span> \
            <span class="n">trunk</span><span class="p">,</span> <span class="n">trunk_undecided</span><span class="p">,</span> <span class="n">unidentified_points</span></div>
            

<div class="viewcode-block" id="POSER.identify_local_tips"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER.identify_local_tips">[docs]</a>    <span class="k">def</span> <span class="nf">identify_local_tips</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">,</span> <span class="n">newseg</span><span class="p">,</span> <span class="n">tip</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Identify new tips within the new segments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newseg : `list`</span>
<span class="sd">            New segment (local with respect to original segment).</span>
<span class="sd">        tip : `int`</span>
<span class="sd">            Local index of the first tip, with respect to the original segment that determinned</span>
<span class="sd">            ``Dseg`` before the split.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tips : `np.ndarray` (2,)</span>
<span class="sd">            First and second tip indices in local coordinates relative to the original segment,</span>
<span class="sd">            before it was branched.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># RE MODIFIED START</span>
        <span class="c1"># if len(np.flatnonzero(newseg)) &lt;= 1:</span>
        <span class="c1">#     logger.warning(f&#39;detected group with only {len(np.flatnonzero(newseg))} data points&#39;)</span>
        <span class="c1"># secondtip = newseg[np.argmax(Dseg[tip][newseg])]</span>
        <span class="c1"># ssegs_tips.append([tip, secondtip]) # RE: SHOULD BE CHANGED</span>

        <span class="n">secondtip</span> <span class="o">=</span> <span class="n">newseg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">tip</span><span class="p">][</span><span class="n">newseg</span><span class="p">])]</span>
        <span class="n">firsttip</span> <span class="o">=</span> <span class="n">tip</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">newseg</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;detected group with only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">newseg</span><span class="p">))</span><span class="si">}</span><span class="s1"> data points&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">firsttip</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">newseg</span><span class="p">):</span>
            <span class="n">new_firsttip</span> <span class="o">=</span> <span class="n">newseg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">tip</span><span class="p">][</span><span class="n">newseg</span><span class="p">])]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;tip is no longer in the unique branched sub-segment, update tip to its nearest point in the new segment: </span><span class="si">{</span><span class="n">firsttip</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">new_firsttip</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">firsttip</span> <span class="o">=</span> <span class="n">new_firsttip</span>

        <span class="n">tips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">firsttip</span><span class="p">,</span> <span class="n">secondtip</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">tips</span></div>

    
<div class="viewcode-block" id="POSER.detect_branching"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER.detect_branching">[docs]</a>    <span class="k">def</span> <span class="nf">detect_branching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> <span class="c1"># , connect_closest=False):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Detect branching on a given segment and update TreeNode parameters in place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : `TreeNode`</span>
<span class="sd">            The node of the segment to be branched.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        updated : `bool`</span>
<span class="sd">            `True` if segment is successfully branched, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># seg_node = self.tree.get_node(self.tree.search(iseg, bottom_up=True))</span>
        <span class="n">allindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">Dseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>        
        <span class="n">tips3</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">allindices</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">]</span> <span class="o">==</span> <span class="n">tip</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tip</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">tips</span><span class="p">]</span> <span class="c1"># local index of tips in the seg</span>
        <span class="n">tips3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tips3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="c1"># given the three tip points and the distance matrix detect the</span>
        <span class="c1"># branching on the segment, return the list ssegs of segments that</span>
        <span class="c1"># are defined by splitting this segment</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_branch</span><span class="p">(</span><span class="n">Dseg</span><span class="p">,</span> <span class="n">tips3</span><span class="p">)</span> <span class="c1"># , connect_closest=connect_closest)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># RE ADDED THIS CONDITION</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No unique branch detected - removed from consideration.&quot;</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">branchable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">updated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ssegs, ssegs_tips, ssegs_adjacency, ssegs_connects, \</span>
            <span class="n">ssegs</span><span class="p">,</span> <span class="n">ssegs_tips</span><span class="p">,</span> <span class="n">ssegs_connects</span><span class="p">,</span> \
                <span class="n">trunk</span><span class="p">,</span> <span class="n">trunk_undecided</span><span class="p">,</span> <span class="n">unidentified</span> <span class="o">=</span> <span class="n">result</span>

            <span class="c1"># map back to global indices</span>
            <span class="n">unidentified</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">unidentified</span><span class="p">]</span> <span class="c1"># record data points not associated with any branch</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;* </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unidentified</span><span class="p">)</span><span class="si">}</span><span class="s2"> unclaimed points.&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">iseg_new</span><span class="p">,</span> <span class="n">seg_new</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs</span><span class="p">):</span>
                <span class="n">ssegs</span><span class="p">[</span><span class="n">iseg_new</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">seg_new</span><span class="p">]</span>
                <span class="n">ssegs_tips</span><span class="p">[</span><span class="n">iseg_new</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ssegs_tips</span><span class="p">[</span><span class="n">iseg_new</span><span class="p">]]</span> 
                <span class="c1"># logger.warning(f&quot;*** {ssegs_connects[iseg_new][-1]}&quot;)</span>
                <span class="c1"># ssegs_connects[iseg_new] = list(node.data[ssegs_connects[iseg_new]])</span>

            <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="n">ssegs_connects</span><span class="p">:</span>
                <span class="n">sc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">sc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

            <span class="c1"># RE ADDED - update unidentified points </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unidentified_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unidentified_points</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">unidentified</span><span class="p">)</span>

            <span class="c1"># insert trunk/undecided_cells with same name</span>
            <span class="n">cur_trunk_node</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">ssegs</span><span class="p">[</span><span class="n">trunk</span><span class="p">],</span>
                                      <span class="n">parent</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">nonunique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unidentified</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">branchable</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_min_branch_size</span><span class="p">(</span><span class="n">ssegs</span><span class="p">[</span><span class="n">trunk</span><span class="p">])</span> <span class="k">else</span> <span class="kc">False</span><span class="p">,</span>
                                      <span class="n">is_trunk</span><span class="o">=</span><span class="n">trunk_undecided</span><span class="p">,</span>
                                      <span class="p">)</span>
            <span class="n">cur_trunk_node</span><span class="o">.</span><span class="n">tips</span> <span class="o">=</span> <span class="n">ssegs_tips</span><span class="p">[</span><span class="n">trunk</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cur_trunk_node</span><span class="p">,</span>
                             <span class="n">parent</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>

            
            <span class="c1"># append other segments</span>
            <span class="n">cur_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># num_segs = len(self.tree.get_leaves())</span>
            <span class="n">num_segs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="p">(</span><span class="n">ixseg</span><span class="p">,</span> <span class="n">ixseg_tips</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ssegs</span><span class="p">,</span> <span class="n">ssegs_tips</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">ix</span> <span class="o">!=</span> <span class="n">trunk</span><span class="p">:</span>
                    <span class="n">cur_node</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">num_segs</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># ix+num_segs,</span>
                                        <span class="n">data</span><span class="o">=</span><span class="n">ixseg</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                                        <span class="n">nonunique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unidentified</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">branchable</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_min_branch_size</span><span class="p">(</span><span class="n">ixseg</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="n">is_trunk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="p">)</span>
                    <span class="n">num_segs</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">cur_node</span><span class="o">.</span><span class="n">tips</span> <span class="o">=</span> <span class="n">ixseg_tips</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cur_node</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">cur_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_node</span><span class="o">.</span><span class="n">_counter</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cur_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_trunk_node</span><span class="o">.</span><span class="n">_counter</span><span class="p">)</span>
            
            <span class="c1"># update edges between nodes</span>
            <span class="c1"># for i, adj in enumerate(ssegs_adjacency):</span>
            <span class="c1">#     self.tree.node_adjacency[cur_nodes[i]] += [cur_nodes[j] for j in adj]</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs_connects</span><span class="p">):</span>
                <span class="n">sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="n">cur_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">node_connection</span> <span class="o">+=</span> <span class="n">ssegs_connects</span>
            <span class="c1"># for i, con in enumerate(ssegs_connects):</span>
            <span class="c1">#     self.tree.node_connection[cur_nodes[i]] += con</span>

            <span class="c1"># NOTE: USED TO HAVE CONDITION FOR NOT HAGHVERDI16</span>

            <span class="n">updated</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">branched_ordering</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">updated</span></div>


<div class="viewcode-block" id="POSER.single_branch"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER.single_branch">[docs]</a>    <span class="k">def</span> <span class="nf">single_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">until_branched</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># , connect_closest=False):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform single branching in place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        until_branched : `bool`</span>
<span class="sd">            If `True`, iteratively find segment to branch and perform branching</span>
<span class="sd">            until a segement is successfully branched or no branchable segments</span>
<span class="sd">            remain. Otherwise, if `False`, attempt to perform branching only once </span>
<span class="sd">            on the next potentially branchable segment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        branched_flag : `bool`</span>
<span class="sd">            Indicates if branching was successfully completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">branched_flag</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># not until_branched # stop when true</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">branched_flag</span><span class="p">:</span>
            
                
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_segment</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;* selected node = </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No branchable segments remain -- partitioning converged.&quot;</span><span class="p">)</span>
                <span class="c1"># branched_flag = True</span>
                <span class="k">break</span>                
            <span class="k">else</span><span class="p">:</span>
                <span class="n">branched_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detect_branching</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="c1"># , connect_closest=connect_closest)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">until_branched</span><span class="p">:</span>
                <span class="c1"># branched_flag = True</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">branched_flag</span></div>
                

<div class="viewcode-block" id="POSER.detect_branches"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER.detect_branches">[docs]</a>    <span class="k">def</span> <span class="nf">detect_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_branches</span><span class="p">,</span> <span class="n">until_branched</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># , connect_closest=False):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Detect up to ``n_branches`` branchings and update tree in place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_branches : `int`</span>
<span class="sd">            Number of branch splits to perform (``n_branches &gt; 0``).</span>
<span class="sd">        until_branched : `bool`</span>
<span class="sd">            If `True`, iteratively find segment to branch and perform branching</span>
<span class="sd">            until a segement is successfully branched or no branchable segments</span>
<span class="sd">            remain. Otherwise, if `False`, attempt to perform branching only once </span>
<span class="sd">            on the next potentially branchable segment.</span>

<span class="sd">            ..note::</span>

<span class="sd">              This is only applicable when branching is being performed. If previous</span>
<span class="sd">              iterations of branching has already been performed, it is not possible to</span>
<span class="sd">              identify the number of iterations where no branching was performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_branches</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branched_ordering</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ibranch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branched_ordering</span><span class="p">),</span> <span class="n">n_branches</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;*ibranch = </span><span class="si">{</span><span class="n">ibranch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">branched_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_branch</span><span class="p">(</span><span class="n">until_branched</span><span class="o">=</span><span class="n">until_branched</span><span class="p">)</span> <span class="c1"># , connect_closest=connect_closest)</span>
                <span class="c1"># logger.warning(f&quot;* was branched = {branched_flag}&quot;)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">branched_flag</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No further branching occured at this iteration.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`n_branches` branchings have already occurred. No further branching is performed.&quot;</span><span class="p">)</span></div>
                
            
<div class="viewcode-block" id="POSER.extract_branchings"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER.extract_branchings">[docs]</a>    <span class="k">def</span> <span class="nf">extract_branchings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_branches</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Extract POSE from up to `n_branches` branchings</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_branches : `int`</span>
<span class="sd">            Number of branches to look for (``n_branches &gt; 0``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tree : `Tree`</span>
<span class="sd">            The tree with up to `n_branches` branchings.</span>
<span class="sd">            If ``n_branches`` is more than or equal to the number of</span>
<span class="sd">            branchings in the tree, the original tree is returned.</span>
<span class="sd">            Otherwise, a reduced tree is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_branches</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branched_ordering</span><span class="p">):</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_branches</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_branches</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branched_ordering</span><span class="p">))</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>

            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branched_ordering</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                <span class="n">nonunique</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">nonunique</span><span class="p">,</span> <span class="n">unidentified</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">unidentified</span><span class="p">,</span>
                                <span class="n">branchable</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">branchable</span><span class="p">,</span> <span class="n">is_trunk</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">is_trunk</span><span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branched_orderings</span><span class="p">[:</span><span class="n">n_branches</span><span class="p">]):</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_node_from_name</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bottom_up</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">_counter</span><span class="p">):</span>
                    <span class="n">new_node</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                                        <span class="n">nonunique</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">nonunique</span><span class="p">,</span> <span class="n">unidentified</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">unidentified</span><span class="p">,</span>
                                        <span class="n">branchable</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">branchable</span><span class="p">,</span> <span class="n">is_trunk</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">is_trunk</span><span class="p">)</span>
                    <span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">)</span>

            <span class="c1"># mx = max([k._counter for k in tree.nodes])</span>
            <span class="c1"># sub_adj = lambda x: [a for a in self.tree.node_adjacency[x] if a &lt;= mx]            </span>
            <span class="c1"># tree.node_adjacency = {counter: sub_adj[counter] for counter in range(mx+1)}</span>
            <span class="c1"># tree.node_adjacency = self.tree.node_adjacency</span>
            <span class="c1"># tree.node_connection = self.tree.node_connection</span>

        <span class="k">return</span> <span class="n">tree</span>            </div>
            
            
<div class="viewcode-block" id="POSER.branchings_segments"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER.branchings_segments">[docs]</a>    <span class="k">def</span> <span class="nf">branchings_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_branches</span><span class="p">,</span> <span class="n">until_branched</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> <span class="c1"># , connect_closest=False):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Detect up to `n_branches` branches and partition the data into corresponding segments.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_branches : `int`</span>
<span class="sd">            Number of branches to look for (``n_branches &gt; 0``).</span>
<span class="sd">        until_branched : `bool`</span>
<span class="sd">            If `True`, iteratively find segment to branch and perform branching</span>
<span class="sd">            until a segement is successfully branched or no branchable segments</span>
<span class="sd">            remain. Otherwise, if `False`, attempt to perform branching only once </span>
<span class="sd">            on the next potentially branchable segment.</span>

<span class="sd">            ..note::</span>

<span class="sd">              This is only applicable when branching is being performed. If previous</span>
<span class="sd">              iterations of branching has already been performed, it is not possible to</span>
<span class="sd">              identify the number of iterations where no branching was performed.</span>
<span class="sd">        annotate : `bool`</span>
<span class="sd">            If `True`, annotate nodes with root and tips.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G : `nx.Graph`</span>
<span class="sd">            The graph of the resulting POSE.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detect_branches</span><span class="p">(</span><span class="n">n_branches</span><span class="p">,</span> <span class="n">until_branched</span><span class="o">=</span><span class="n">until_branched</span><span class="p">)</span> <span class="c1"># , connect_closest=connect_closest)</span>

        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_branchings</span><span class="p">(</span><span class="n">n_branches</span><span class="p">)</span>

        <span class="n">leaves</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()</span>
        <span class="n">segs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">:</span>
            <span class="n">tips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tips</span><span class="p">)</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">segs</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">_counter</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                   <span class="s1">&#39;tips&#39;</span><span class="p">:</span> <span class="n">tips</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudo_dist</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">tips</span><span class="p">])],</span>
                                   <span class="s1">&#39;seg&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudo_dist</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">])],</span>
                                   <span class="s1">&#39;undecided&#39;</span> <span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">is_trunk</span><span class="p">,</span>
                                   <span class="p">}</span>

        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_topology</span><span class="p">(</span><span class="n">segs</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="n">annotate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="s1">&#39;Yes&#39;</span> <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="k">else</span> <span class="s1">&#39;No&#39;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G</span><span class="p">},</span>
                                   <span class="n">name</span><span class="o">=</span><span class="s1">&#39;is_root&#39;</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">vl</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">vl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudo_dist</span><span class="p">)},</span>
                           <span class="n">name</span><span class="o">=</span><span class="s1">&#39;pseudo-distance from root&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="POSER._construct_topology"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER._construct_topology">[docs]</a>    <span class="k">def</span> <span class="nf">_construct_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segs</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Construct POSE connections between data points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segs : `dict`</span>
<span class="sd">            The banched segments indexed by the node&#39;s unique identifier.</span>
<span class="sd">        annotate : `bool`</span>
<span class="sd">            If `True`, annotate edges with edge origin and distance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G : `networkx.Graph`</span>
<span class="sd">            Graph where each node is a data point and edges reflect connections between them.</span>
<span class="sd">            If ``annotate`` is `True`, the following annotations are added:</span>
<span class="sd">        </span>
<span class="sd">            - Edges have attributes:</span>

<span class="sd">                - &#39;connection&#39; : (str) &#39;intra-branch&#39; or &#39;inter-branch&#39;}</span>
<span class="sd">            - Nodes have attributes:</span>

<span class="sd">                - &#39;branch&#39; : (`int`) -1, 0, 1, ... where -1 indicates the data point was not identified with a branch</span>
<span class="sd">                - &#39;undecided&#39; : (bool) True if the data point is part of a trunk and False otherwise</span>
<span class="sd">                - &#39;name&#39; : (str) Original label if given data was a dataframe, otherwise the same as the node id</span>
<span class="sd">                - &#39;unidentified&#39; : (0 or 1) 1 if data point was ever not associated with any branch upon split, 0 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

        <span class="c1"># add missing nodes as island nodes</span>
        <span class="n">seg_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="s1">&#39;seg&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">segs</span><span class="o">.</span><span class="n">values</span><span class="p">()]))</span>
        <span class="n">missing_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">-</span> <span class="n">seg_nodes</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">missing_nodes</span><span class="p">),</span> <span class="n">branch</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">missing_nodes</span><span class="p">},</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;undecided&#39;</span><span class="p">)</span>

        <span class="c1"># add segments and intra-segemnt edges</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="s1">&#39;seg&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="s1">&#39;seg&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="s1">&#39;seg&#39;</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="s1">&#39;seg&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">connection</span><span class="o">=</span><span class="s1">&#39;intra-branch&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;branch&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
                                               <span class="s1">&#39;undecided&#39;</span><span class="p">:</span> <span class="n">seg</span><span class="p">[</span><span class="s1">&#39;undecided&#39;</span><span class="p">],</span>
                                               <span class="p">}</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">seg</span><span class="p">[</span><span class="s1">&#39;seg&#39;</span><span class="p">]})</span>

        <span class="c1"># add inter-segment edges</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">segs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># segs_adjacency = sp.sparse.lil_matrix((mx, mx), dtype=float)</span>
        <span class="c1"># segs_connection = sp.sparse.lil_matrix((mx, mx), dtype=float)</span>
        <span class="n">inter_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">node_connection</span> <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">ix</span> <span class="o">&lt;=</span> <span class="n">mx</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]])]</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">inter_edges</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="s1">&#39;inter-branch&#39;</span><span class="p">)</span>

        <span class="c1"># add node names</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">observation_labels</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>


        <span class="c1"># add if node was ever an unidentified point:</span>
        <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unidentified_points</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">},</span>
                                   <span class="n">name</span><span class="o">=</span><span class="s1">&#39;unidentified&#39;</span><span class="p">)</span>

            <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ee</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()},</span>
                                   <span class="n">name</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-6</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                                          <span class="n">ee</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()},</span>
                                   <span class="n">name</span><span class="o">=</span><span class="s2">&quot;inverted_distance&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="POSER.construct_pose_nn_topology"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER.construct_pose_nn_topology">[docs]</a>    <span class="k">def</span> <span class="nf">construct_pose_nn_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">mutual</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">k_mnn</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Add nearest neighbor (nn) edges to POSE topology.</span>

<span class="sd">        .. note:: Mutual nns tend to be sparser than nns so allow to select more</span>
<span class="sd">                  than just the first nn if restricting to mutual neighbors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : `networkx.Graph`</span>
<span class="sd">            Nearest-neighbor edges are added to a copy of the POSE graph.</span>
<span class="sd">        mutual : `bool` (default = `False`)</span>
<span class="sd">            If `True`, add ``k_mnn`` mutual nn edges. Otherwise, add single nn edge.</span>
<span class="sd">            When `False`, ``k_mnn`` is ignored.</span>
<span class="sd">        k_mnn : `int` (``0 &lt; k_mnn &lt; len(G)``)</span>
<span class="sd">            The number of nns to consider when extracting mutual nns.</span>
<span class="sd">            Note, this is ignored when ``mutual`` is `False`.</span>
<span class="sd">        annotate : `bool`</span>
<span class="sd">            If `True`, annotate edges.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Gnn : `networkx.Graph`</span>
<span class="sd">            The updated graph with nearest neighbor edges.</span>
<span class="sd">            If ``annotate`` is `True`, edge attribute &quot;edge_origin&quot;</span>
<span class="sd">            is added with the possible values :</span>

<span class="sd">            - &quot;POSE&quot; : for edges in the original graph that are not nearest neighbor edges</span>
<span class="sd">            - &quot;NN&quot; : for nearest neighbor edges that were not in the original graph</span>
<span class="sd">            - &quot;POSE + NN&quot; : for edges in the original graph that are also nearest neighbor edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Gnn</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span>
        <span class="c1"># d = d + (np.max(d)+1e-3)*np.eye(*d.shape)</span>

        <span class="k">if</span> <span class="n">mutual</span><span class="p">:</span>
            <span class="n">nn_edges</span> <span class="o">=</span> <span class="n">mutual_knn_edges</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="n">k_mnn</span><span class="p">)</span>
            <span class="n">nn_edges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ee</span><span class="p">))</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">nn_edges</span><span class="p">]</span>  <span class="c1"># TODO: this might be redundant if returned in sorted order already</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># nn = np.argmin(d, axis=0)        </span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>            
            <span class="n">nn_edges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">nn</span><span class="p">)]</span>
            <span class="n">nn_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nn_edges</span><span class="p">))</span>
            
        
        <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
            <span class="c1"># nn_edges = [tuple(sorted([i,j])) for i, j in zip(range(d.shape[0]), nn)]</span>
            <span class="c1"># nn_edges = list(set(nn_edges))</span>

            <span class="n">pose_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ee</span><span class="p">))</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">Gnn</span><span class="o">.</span><span class="n">edges</span><span class="p">()]))</span>

            <span class="n">nn_unique_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nn_edges</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">pose_edges</span><span class="p">))</span>
            <span class="n">pose_unique_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pose_edges</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">nn_edges</span><span class="p">))</span>
            <span class="n">nn_pose_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nn_edges</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">pose_edges</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nn_unique_edges</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nn_pose_edges</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nn_edges</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Unexpected number of nearest-neighbor edges.&quot;</span><span class="p">)</span>

            <span class="n">Gnn</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">nn_unique_edges</span><span class="p">)</span>

            <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">Gnn</span><span class="p">,</span> <span class="p">{</span><span class="o">**</span><span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="s2">&quot;POSE + NN&quot;</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">nn_pose_edges</span><span class="p">},</span>
                                         <span class="o">**</span><span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="s2">&quot;NN&quot;</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">nn_unique_edges</span><span class="p">},</span>
                                         <span class="o">**</span><span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="s2">&quot;POSE&quot;</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">pose_unique_edges</span><span class="p">}},</span>
                                   <span class="n">name</span><span class="o">=</span><span class="s2">&quot;edge_origin&quot;</span><span class="p">)</span>

            <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">Gnn</span><span class="p">,</span> <span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="s2">&quot;intra-branch&quot;</span> <span class="k">if</span> <span class="n">Gnn</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;branch&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">Gnn</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ee</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;branch&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;inter-branch&quot;</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">nn_unique_edges</span><span class="p">},</span>
                                   <span class="n">name</span><span class="o">=</span><span class="s2">&quot;connection&quot;</span><span class="p">)</span>

            <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">Gnn</span><span class="p">,</span> <span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ee</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">Gnn</span><span class="o">.</span><span class="n">edges</span><span class="p">()},</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">Gnn</span><span class="p">,</span> <span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-6</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ee</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">Gnn</span><span class="o">.</span><span class="n">edges</span><span class="p">()},</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;inverted_distance&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># nn_edges = [tuple([i,j]) for i, j in zip(range(d.shape[0]), nn)]</span>
            <span class="n">Gnn</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">nn_edges</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Gnn</span></div>


<div class="viewcode-block" id="POSER.construct_pose_mst_topology"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.POSER.construct_pose_mst_topology">[docs]</a>    <span class="k">def</span> <span class="nf">construct_pose_mst_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Construct pose topology with minimum spanning tree (MST) edges. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : `networkx.Graph`</span>
<span class="sd">            The POSE graph. MST edges are added to a copy of the graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Gmst : `networkx.Graph`</span>
<span class="sd">            The updated graph with MST edges and edge attribute &quot;edge_origin&quot;</span>
<span class="sd">            with the possible values :</span>

<span class="sd">            - &quot;POSE&quot; : for edges in the original graph that are not MST edges</span>
<span class="sd">            - &quot;MST&quot; : for MST edges that were not in the original graph</span>
<span class="sd">            - &quot;POSE + MST&quot; : for edges in the original graph that are also MST edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">d</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">)</span>
        <span class="n">edgelist</span> <span class="o">=</span> <span class="n">utl</span><span class="o">.</span><span class="n">stack_triu_</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">edgelist</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;weight&#39;</span>
        <span class="n">edgelist</span> <span class="o">=</span> <span class="n">edgelist</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;level_0&#39;</span><span class="p">:</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;level_1&#39;</span><span class="p">:</span> <span class="s1">&#39;target&#39;</span><span class="p">})</span>
        <span class="n">Gfull</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span><span class="n">edgelist</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>
        <span class="n">Gmst</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_spanning_tree</span><span class="p">(</span><span class="n">Gfull</span><span class="p">)</span>

        <span class="n">mst_edges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">Gmst</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
        <span class="n">mst_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mst_edges</span><span class="p">))</span>

        <span class="n">pose_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ee</span><span class="p">))</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]))</span>

        <span class="n">mst_unique_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mst_edges</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">pose_edges</span><span class="p">))</span>
        <span class="n">pose_unique_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pose_edges</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">mst_edges</span><span class="p">))</span>
        <span class="n">mst_pose_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mst_edges</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">pose_edges</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mst_unique_edges</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">mst_pose_edges</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mst_edges</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Unexpected number of MST edges.&quot;</span><span class="p">)</span>

        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">mst_unique_edges</span><span class="p">)</span>

        <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="o">**</span><span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="s2">&quot;POSE + MST&quot;</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">mst_pose_edges</span><span class="p">},</span>
                                   <span class="o">**</span><span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="s2">&quot;MST&quot;</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">mst_unique_edges</span><span class="p">},</span>
                                   <span class="o">**</span><span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="s2">&quot;POSE&quot;</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">pose_unique_edges</span><span class="p">}},</span>
                               <span class="n">name</span><span class="o">=</span><span class="s2">&quot;edge_origin&quot;</span><span class="p">)</span>

        <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ee</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()},</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">ee</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-6</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ee</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()},</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;inverted_distance&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div></div>
</pre></div>

                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="../../../building/index.html">Installation</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="../../../overview/index.html">User guide</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="../../../tutorial/index.html">Tutorials</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="../../../reference/index.html">API reference</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="../../../references.html">References</a></li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
      © Copyright 2023-2025, The netflow community.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    <br/>
  </p>
</div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>