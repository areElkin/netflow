

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>netflow.pose.organization &#8212; netflow v0.0.dev Manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/netflow/pose/organization';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    <p class="title logo__title">netflow v0.0.dev Manual</p>
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../building/index.html">
                        Installation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../reference/index.html">
                        API reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../tutorial/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../references.html">
                        References
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../building/index.html">
                        Installation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../reference/index.html">
                        API reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../tutorial/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../references.html">
                        References
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item"><nav class="sidebar-indices-items">
  <p class="sidebar-indices-items__title" role="heading" aria-level="1">Indices</p>
  <ul class="indices-link">
        <li class="toctree-l1">
          <a class="reference internal"
             href="../../../genindex.html"
             accesskey="I">General Index</a>
        </li>
        <li class="toctree-l1">
          <a class="reference internal" href="../../../py-modindex.html">Python Module Index</a>
        </li>
  </ul>
</nav></div>
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">netflow.pose.organization</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for netflow.pose.organization</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">organization</span>
<span class="sd">============</span>

<span class="sd">**Description**</span>

<span class="sd">The purpose of This module is to construct the organization of the</span>
<span class="sd">schema from a distance matrix and a single (or multiple)</span>
<span class="sd">data point(s) designated as the source.</span>

<span class="sd">This is done by using the branch detection algorithm</span>
<span class="sd">from the diffusion pseudo-time (DPT) algorithm for reconstructing</span>
<span class="sd">developmental progression and differentiation of cells proposed</span>
<span class="sd">in [Haghverdi16]_ as implemented in scanpy.</span>

<span class="sd">**Acknowledgement**</span>

<span class="sd">A large portion of the code was taken from</span>
<span class="sd">scanpy.tools._dpt.py and code related to</span>
<span class="sd">the method :mod:`scanpy.tools._dpt.dpt`.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>

<span class="c1"># import netflow.utils as utl</span>
<span class="kn">import</span> <span class="nn">netflow.utils</span> <span class="k">as</span> <span class="nn">utl</span>
<span class="c1"># from importlib import reload</span>
<span class="c1"># reload(utl)</span>
<span class="kn">from</span> <span class="nn">.._logging</span> <span class="kn">import</span> <span class="n">logger</span>

<span class="c1"># RE: TODO: ADD OPTION FOR MULTIPLE ROOTS</span>
<span class="c1">### RE: TODO: ADD OPTION TO SELECT ROOT, IF NOT PROVIDED</span>
<span class="c1">### RE: TODO: CHECK HOW UNIQUE BRANCHES ARE DETERMINED</span>
<span class="c1"># RE: TODO: CHECK WHICH TRANSITION MATRIX IS USED AND HOW IT&#39;S DEFINED</span>
<span class="c1">### RE: TODO: CHECK HOW BRANCHING CONNECTIONS IS DEFINED WHEN THERE IS A TRUNK</span>
<span class="c1">### RE: TODO: IF GIVE ROOT AS NAME OF DATA POINT (WHEN DISTANCES IS A DATAFRAME), CONVERT IT TO INT</span>
<span class="c1">### RE: TODO: ADD OPTION FOR SMOOTHING CORR BEFORE FINDING MAX</span>
<span class="c1"># RE: TODO: IF MAX CORR &lt; THRESH, MAYBE DON&quot;T INCLUDE BRANCH?</span>
<span class="c1"># RE: TODO: ADD OPTION TO CHANGE ROOT AND UPDATE PSEUDOTIME, SEGS, AND ORDERING? -- this should be for earlier step in pipeline</span>
<span class="c1"># RE: TODO: SHOULD -1 be included in segs_names_unique?</span>


<div class="viewcode-block" id="PseudoOrdering"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.PseudoOrdering">[docs]</a><span class="k">class</span> <span class="nc">PseudoOrdering</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Pseudo-ordering of observations (e.g., samples). </span>

<span class="sd">    Represent data matrix as a graph of associations (i.e., edges) among data points (i.e., observations or nodes).</span>

<span class="sd">    Results are stored to the keeper as a `dict`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keeper : `netflow.Keeper`</span>
<span class="sd">        The keeper object that stores the symmetric similarity matrix of size (n_observations, n_observations).</span>
<span class="sd">    key : `str`</span>
<span class="sd">        The label used to reference the similarity matrix stored in ``keeper.similarities``,</span>
<span class="sd">        of size (n_observations, n_observations).</span>
<span class="sd">    label : str</span>
<span class="sd">        Label used to store resulting organization schema in ``keeper.misc[label]``.</span>
<span class="sd">    root : `int`</span>
<span class="sd">        Index of root obs that pesudo-ordering is computed from (``root &gt; 0``).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="PseudoOrdering.__init__"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.PseudoOrdering.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keeper</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keeper</span> <span class="o">=</span> <span class="n">keeper</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># pairwise-obs distances of size :math:`(n_observations, n_observations)`, which gives the</span>
        <span class="c1"># norm of distance over all features in `all_feats_pairwise_obs_dists`:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distances</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_similarities</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">similarities</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="c1"># None # convert `_distances` to `similarity` measure.</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">_transitions_asym</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transitions_sym</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime_distances</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="c1"># @property</span>
    <span class="c1"># def distances(self):</span>
    <span class="c1">#     &quot;&quot;&quot; Distances between data points. &quot;&quot;&quot;        </span>
    <span class="c1">#     return self._distances</span>


    <span class="c1"># @property</span>
    <span class="c1"># def similarities(self):</span>
    <span class="c1">#     &quot;&quot;&quot; Similarities between data points. &quot;&quot;&quot;        </span>
    <span class="c1">#     return self._similarities</span>


    <span class="c1"># this is now netflow.methods.metrics.norm_features_as_sym_dist()</span>
    <span class="c1"># def compute_norm_features(self):</span>
    <span class="c1">#     &quot;&quot;&quot; Compute norm of obs-pairwise distances with respect to all features in `all_feats_pairwise_obs_dists` returned</span>
    <span class="c1">#     as symmetric obs-pairwise distance matrix of size (m, m).</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     self._distances = utl.unstack_triu_(norm_features_(self.all_feats_pairwise_obs_dists,</span>
    <span class="c1">#                                                       method=self._method_norm),</span>
    <span class="c1">#                                         index=self.index)</span>


    <span class="c1"># this is now def sigma_knn() and def sigma_knn_()</span>
    <span class="c1"># def compute_sigma_knn(self):</span>
    <span class="c1">#     &quot;&quot;&quot; Compute sigmas from nearest neighbors. &quot;&quot;&quot;</span>
    <span class="c1">#     if self._distances is None:</span>
    <span class="c1">#         msg = &quot;Must compute distances before sigmas can be computed, running `compute_norm_features` now.&quot;</span>
    <span class="c1">#         logger.msg(msg)</span>
    <span class="c1">#         self.compute_norm_features()</span>
            
    <span class="c1">#     self._sigmas, self._nn_indices, self._nn_distances = sigma_knn_(self._distances, n_neighbors=self._n_neighbors, method=self._method_sigma, return_nn=True)</span>

        
    <span class="c1"># def compute_similarity_measure(self):</span>
    <span class="c1">#     &quot;&quot;&quot; convert `_distances` to `similarity` measure. &quot;&quot;&quot;</span>
    <span class="c1">#     if self._distances is None:</span>
    <span class="c1">#         msg = &quot;Must compute distances before similarities can be computed, running `compute_norm_features` now.&quot;</span>
    <span class="c1">#         # raise AssertionError(msg)</span>
    <span class="c1">#         logger.msg(msg)</span>
    <span class="c1">#         self.compute_norm_features()        </span>

    <span class="c1">#     if self._method_sigma == &#39;precomputed&#39;:</span>
    <span class="c1">#         self._similarities = similarity_measure_(self._distances, self._n_neighbors, self._method_sigma, sigmas=self._sigmas, knn=self._knn, indices=self._nn_indices)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         # if not yet computed, compute sigmas so computation performed only once and save values</span>
    <span class="c1">#         if (self._sigmas is None) or (self._knn and (self._nn_indices is None)):</span>
    <span class="c1">#             self.compute_sigma_knn()</span>
                
    <span class="c1">#         self._similarities = similarity_measure_(self._distances, self._n_neighbors, &#39;precomputed&#39;, sigmas=self._sigmas, knn=self._knn, indices=self._nn_indices)</span>

<div class="viewcode-block" id="PseudoOrdering.compute_transitions"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.PseudoOrdering.compute_transitions">[docs]</a>    <span class="k">def</span> <span class="nf">compute_transitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">similarities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density_normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute transition matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        similarities : `numpy.ndarray`, (m, m)</span>
<span class="sd">            Symmetric similarity measure.</span>
<span class="sd">        density_normalize : `bool`</span>
<span class="sd">            The density rescaling of Coifman and Lafon (2006): Then only the</span>
<span class="sd">            geometry of the data matters, not the sampled density.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Makes attributes ``.transitions_sym`` and ``.transitions`` available.</span>

<span class="sd">        Notes</span>
<span class="sd">        --------</span>
<span class="sd">        Code copied from `scanpy.neighbors`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    
        <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_similarities</span> <span class="k">if</span> <span class="n">similarities</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">similarities</span>
        <span class="c1"># density normalization as of Coifman et al. (2005)</span>
        <span class="c1"># ensures that kernel matrix is independent of sampling density</span>
        <span class="k">if</span> <span class="n">density_normalize</span><span class="p">:</span>
            <span class="c1"># q[i] is an estimate for the sampling density at point i</span>
            <span class="c1"># it&#39;s also the degree of the underlying graph</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">issparse</span><span class="p">(</span><span class="n">W</span><span class="p">):</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">q</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">@</span> <span class="n">W</span> <span class="o">@</span> <span class="n">Q</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">W</span>

        <span class="c1"># asym transitions</span>
        <span class="c1"># z[i] is the row sum of K</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">issparse</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transitions_asym</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">@</span> <span class="n">K</span>

        <span class="c1"># sym transitions</span>
        <span class="c1"># z[i] is the square root of the row sum of K</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">issparse</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transitions_sym</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">Z</span></div>

        <span class="c1"># to compute first eigenvector phi0 if did density normalization (from matlab code):</span>
        <span class="c1"># D1_ = np.asarray(K.sum(axis=0))</span>
        <span class="c1"># phi0 = D1_ / np.sqrt(np.power(D1_, 2).sum())  # TODO: check if ever need this to be sparse</span>


<div class="viewcode-block" id="PseudoOrdering._set_pseudotime"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.PseudoOrdering._set_pseudotime">[docs]</a>    <span class="k">def</span> <span class="nf">_set_pseudotime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return pseudotime with respect to root point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root : `int`, 0 &lt;= root &lt; m where m is the number of obs.</span>
<span class="sd">            Root obs for computing pseudo-ordering. If `None`, ``self.root`` is used.</span>
<span class="sd">            If provided, ``self.root`` is updated to ``root``.</span>
<span class="sd">        ordering : {&#39;distance&#39;, &#39;similarity&#39;, &#39;transitions_asym&#39;, &#39;transitions_sym&#39;, &#39;precomputed&#39;}</span>
<span class="sd">            Metric by which pseudo-ordering should be computed.</span>

<span class="sd">            Options:</span>

<span class="sd">            - &#39;distance&#39; : ``self._distances``</span>
<span class="sd">            - &#39;similarity&#39; : 1 - ``self._similarities``</span>
<span class="sd">            - &#39;transitions_asym&#39; : 1 - ``self._transitions_asym``</span>
<span class="sd">            - &#39;transitions_sym&#39; : 1 - ``self._transitions_sym``</span>
<span class="sd">            - &#39;precomputed&#39; : 1 - precomputed</span>
<span class="sd">        data :</span>
<span class="sd">            Similarity matrix used when ``ordering = &#39;precomputed&#39;``.</span>
<span class="sd">            Note, this is ignored if ``ordering`` is not &quot;precomputed&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span> <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">root</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;root&#39; must be specified in order to compute pseudo-ordering.&quot;</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ordering</span> <span class="o">==</span> <span class="s1">&#39;distance&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">ordering</span> <span class="o">==</span> <span class="s1">&#39;similarity&#39;</span><span class="p">:</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_similarities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pt</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">-</span> <span class="n">pt</span>

        <span class="k">elif</span> <span class="n">ordering</span> <span class="o">==</span> <span class="s1">&#39;transitions_asym&#39;</span><span class="p">:</span>
            <span class="c1"># not setting self to 1 - transition in case root has transition probability of 1 to another obs, and want self to have smallest pseudotime</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transitions_asym</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pt</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">-</span> <span class="n">pt</span>

        <span class="k">elif</span> <span class="n">ordering</span> <span class="o">==</span> <span class="s1">&#39;transitions_sym&#39;</span><span class="p">:</span>
            <span class="c1"># not setting self to 1 - transition in case root has transition probability of 1 to another obs, and want self to have smallest pseudotime</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transitions_sym</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pt</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">-</span> <span class="n">pt</span>

        <span class="k">elif</span> <span class="n">ordering</span> <span class="o">==</span> <span class="s1">&#39;precomputed&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Must provide `data` when ordering is precomputed.&quot;</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="n">pt</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pt</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">-</span> <span class="n">pt</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unrecognized value </span><span class="si">{</span><span class="n">ordering</span><span class="si">!r}</span><span class="s2"> for `ordering`, must be one of [&#39;distance&#39;, &#39;similarity&#39;, &#39;transitions_asym&#39;, &#39;transitions_sym&#39;].&quot;</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>            
            
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span></div>


<div class="viewcode-block" id="PseudoOrdering.pseudotime_distances"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.PseudoOrdering.pseudotime_distances">[docs]</a>    <span class="k">def</span> <span class="nf">pseudotime_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>        
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute distance matrix used for pseudotime branching.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ordering : {&#39;distance&#39;, &#39;similarity&#39;, &#39;transitions_asym&#39;, &#39;transitions_sym&#39;, &#39;precomputed&#39;}</span>
<span class="sd">            Metric by which pseudo-ordering should be computed.</span>

<span class="sd">            Options:</span>

<span class="sd">            - &#39;distance&#39; : ``self._distances``</span>
<span class="sd">            - &#39;similarity&#39; : 1 - ``self._similarities``</span>
<span class="sd">            - &#39;transitions_asym&#39; : 1 - ``self._transitions_asym``</span>
<span class="sd">            - &#39;transitions_sym&#39; : 1 - ``self._transitions_sym``</span>
<span class="sd">            - &#39;precomputed&#39; : 1 - precomputed</span>
<span class="sd">        data :</span>
<span class="sd">            Similarity matrix used when ``ordering = &#39;precomputed&#39;``.</span>
<span class="sd">            Note, this is ignored if ``ordering`` is not &quot;precomputed&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    
        <span class="k">if</span> <span class="n">ordering</span> <span class="o">==</span> <span class="s1">&#39;distance&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime_distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distances</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">ordering</span> <span class="o">==</span> <span class="s1">&#39;similarity&#39;</span><span class="p">:</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_similarities</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">-</span> <span class="n">pt</span>

        <span class="k">elif</span> <span class="n">ordering</span> <span class="o">==</span> <span class="s1">&#39;transitions_asym&#39;</span><span class="p">:</span>
            <span class="c1"># not setting self to 1 - transition in case root has transition probability of 1 to another obs, and want self to have smallest pseudotime</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transitions_asym</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">-</span> <span class="n">pt</span>

        <span class="k">elif</span> <span class="n">ordering</span> <span class="o">==</span> <span class="s1">&#39;transitions_sym&#39;</span><span class="p">:</span>
            <span class="c1"># not setting self to 1 - transition in case root has transition probability of 1 to another obs, and want self to have smallest pseudotime</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transitions_sym</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">-</span> <span class="n">pt</span>

        <span class="k">elif</span> <span class="n">ordering</span> <span class="o">==</span> <span class="s1">&#39;precomputed&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Must provide `data` when ordering is precomputed.&quot;</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transitions_sym</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">-</span> <span class="n">pt</span>
            

        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unrecognized value </span><span class="si">{</span><span class="n">ordering</span><span class="si">!r}</span><span class="s2"> for `ordering`, must be one of [&#39;distance&#39;, &#39;similarity&#39;, &#39;transitions_asym&#39;, &#39;transitions_sym&#39;].&quot;</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>            </div></div>



<span class="c1"># to do: change to schema</span>
<div class="viewcode-block" id="TDA"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA">[docs]</a><span class="k">class</span> <span class="nc">TDA</span><span class="p">:</span>    
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Class to compute topological branching analysis</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keeper : `netflow.Keeper`</span>
<span class="sd">        The keeper object that stores the distance matrix of size (n_observations, n_observations).</span>
<span class="sd">    key : `str`</span>
<span class="sd">        The label used to reference the distance matrix stored in ``keeper.distances``,</span>
<span class="sd">        of size (n_observations, n_observations).</span>
<span class="sd">    label : `str`</span>
<span class="sd">        Label used to store resulting schema in ``keeper.misc[label]``.</span>
<span class="sd">    min_branch_size : {`int`, `float`}</span>
<span class="sd">        During recursive splitting of branches, only consider splitting a branch with at least</span>
<span class="sd">        ``min_branch_size &gt; 2`` data points.</span>
<span class="sd">        If a `float`, ``min_branch_size`` refers to the fraction of the total number of data points</span>
<span class="sd">        (``0 &lt; min_branch_size &lt; 1``).</span>
<span class="sd">    choose_largest_segment : `bool`</span>
<span class="sd">        ?</span>
<span class="sd">    flavor : {&#39;haghverdi16&#39;, &#39;wolf17_tri&#39;, &#39;wolf17_bi&#39;, &#39;wolf17_bi_un&#39;}</span>
<span class="sd">        ?</span>
<span class="sd">    allow_kendall_tau_shift : `bool`</span>
<span class="sd">        If a very small branch is detected upon splitting, shift away from</span>
<span class="sd">        maximum correlation in Kendall tau criterion of [Haghverdi16]_ to</span>
<span class="sd">        stabilize the splitting.</span>
<span class="sd">    root : `int`</span>
<span class="sd">        Index of root obs that pesudo-ordering is computed from (``root &gt; 0``).</span>
<span class="sd">    smooth_corr : `bool`, default = `False`</span>
<span class="sd">        If `True`, smooth correlations before identifying cut points for branch splitting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="TDA.__init__"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keeper</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># distances,</span>
                 <span class="n">min_branch_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">choose_largest_segment</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">flavor</span><span class="o">=</span><span class="s1">&#39;haghverdi16&#39;</span><span class="p">,</span> <span class="n">allow_kendall_tau_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">smooth_corr</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># TODO: set root upfront and call _set_pseudotime after distance is computed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keeper</span> <span class="o">=</span> <span class="n">keeper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distances</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_branch_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">min_branch_size</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;As an integer, `min_branch_size` must be greater than 2.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_min_branch_size</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">min_branch_size</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_branch_size</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">assert</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">min_branch_size</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">,</span> <span class="s2">&quot;As a float, `min_branch_size` must satisfy 0 &lt; `min_branch_size` &lt; 1.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_min_branch_size</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_branch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_branch_size</span> <span class="o">=</span> <span class="n">min_branch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choose_largest_segment</span> <span class="o">=</span> <span class="n">choose_largest_segment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">=</span> <span class="n">flavor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_kendall_tau_shift</span> <span class="o">=</span> <span class="n">allow_kendall_tau_shift</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set root as index of row with largest distance</span>
            <span class="c1"># logger.msg(f&quot;Suggesting root node -- to be implemented....&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">msg</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Suggested root set as index </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">keeper</span><span class="o">.</span><span class="n">observation_labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_pseudotime</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">smooth_corr</span> <span class="o">=</span> <span class="n">smooth_corr</span></div>

        
<div class="viewcode-block" id="TDA.detect_branches"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA.detect_branches">[docs]</a>    <span class="k">def</span> <span class="nf">detect_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_branches</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Detect up to `n_branches` branches.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_branches : `int`</span>
<span class="sd">            Number of branches to look for (`n_branches` &gt; 0).</span>
<span class="sd">    </span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Writes : </span>

<span class="sd">        - segs : `list`</span>
<span class="sd">        </span>
<span class="sd">          * list of arrays of length (number of segments). Each entry stores</span>
<span class="sd">            the indices of the members of a segment.</span>
<span class="sd">        - segs_tips : `list`</span>
<span class="sd">        </span>
<span class="sd">          * List of arrays of length (number of segments) where Each entry stores the</span>
<span class="sd">            indices of the two tip points of each segment.</span>
<span class="sd">        - segs_undecided :</span>
<span class="sd">        </span>
<span class="sd">          * ?</span>
<span class="sd">        - segs_adjacency :</span>
<span class="sd">        </span>
<span class="sd">          * ?</span>
<span class="sd">        - segs_connects :</span>
<span class="sd">        </span>
<span class="sd">          * ?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># distances = distances if not isinstance(self.distances, pd.DataFrame) else distances.values</span>
        
        <span class="n">indices_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># branch_hierarchy = [indices_all]  # keep record</span>
        <span class="n">segs</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices_all</span><span class="p">]</span>

        <span class="c1"># get first tip (farthest from root)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tip_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tip_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">])</span>

        <span class="c1"># get tip of other end (farthest from tip_0)</span>
        <span class="n">tips_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tip_0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">tip_0</span><span class="p">])])</span>
        <span class="c1"># branch_tips = [tips_all]  # keep record</span>
        <span class="n">segs_tips</span> <span class="o">=</span> <span class="p">[</span><span class="n">tips_all</span><span class="p">]</span>

        <span class="n">segs_connects</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="n">segs_undecided</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span>
        <span class="n">segs_adjacency</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="n">segs_terminate_branching</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>  <span class="c1"># RE added - to indicate if segment has already been branched as much as possible </span>
        
        <span class="k">for</span> <span class="n">ibranch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_branches</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;*ibranch = </span><span class="si">{</span><span class="n">ibranch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;*</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span><span class="si">}</span><span class="s2"> segs = </span><span class="si">{</span><span class="n">segs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">iseg</span><span class="p">,</span> <span class="n">tips3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_segment</span><span class="p">(</span><span class="n">segs</span><span class="p">,</span> <span class="n">segs_tips</span><span class="p">,</span> <span class="n">segs_undecided</span><span class="p">,</span> <span class="n">segs_terminate_branching</span><span class="p">)</span>
            <span class="c1"># logger.warning(f&quot;*iseg = {iseg}, tips3 = {tips3}, selected_seg = {segs[iseg]}&quot;)</span>
            <span class="k">if</span> <span class="n">iseg</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    partitioning converged: ibranch = </span><span class="si">{</span><span class="n">ibranch</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;    branching </span><span class="si">{</span><span class="n">ibranch</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">: split group </span><span class="si">{</span><span class="n">iseg</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="p">)</span>  <span class="c1"># [third start end]</span>
            <span class="c1"># detect branching and update segs and segs_tips</span>
            <span class="n">n_segs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">detect_branching</span><span class="p">(</span>
                <span class="n">segs</span><span class="p">,</span>
                <span class="n">segs_tips</span><span class="p">,</span>
                <span class="n">segs_connects</span><span class="p">,</span>
                <span class="n">segs_undecided</span><span class="p">,</span>
                <span class="n">segs_adjacency</span><span class="p">,</span>
                <span class="n">iseg</span><span class="p">,</span>
                <span class="n">tips3</span><span class="p">,</span>
                <span class="n">segs_terminate_branching</span><span class="p">,</span>
            <span class="p">)</span>
            
            <span class="c1"># RE START MODIFIED - added to indicate when segment should not be further branched</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_segs</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No further branching occured at this iteration.&quot;</span><span class="p">)</span>
                <span class="n">segs_terminate_branching</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                

        <span class="c1"># store as class members</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segs</span> <span class="o">=</span> <span class="n">segs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segs_tips</span> <span class="o">=</span> <span class="n">segs_tips</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segs_undecided</span> <span class="o">=</span> <span class="n">segs_undecided</span>
        <span class="c1"># the following is a bit too much, but this allows easy storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segs_adjacency</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segs_connects</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg_adjacency</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segs_adjacency</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segs_connects</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">seg_adjacency</span><span class="p">]</span> <span class="o">=</span> <span class="n">segs_connects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">segs_adjacency</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">segs_connects</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">segs_connects</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segs_adjacency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segs_adjacency</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segs_connects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segs_connects</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span></div>

        <span class="c1"># RE: Add for points that weren&#39;t found in any of the resulting segments</span>


<div class="viewcode-block" id="TDA.select_segment"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA.select_segment">[docs]</a>    <span class="k">def</span> <span class="nf">select_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segs</span><span class="p">,</span> <span class="n">segs_tips</span><span class="p">,</span> <span class="n">segs_undecided</span><span class="p">,</span> <span class="n">segs_terminate_branching</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Select segment with most distant second data point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iseg</span>
<span class="sd">            Index identifying the position within the list of line segments.</span>
<span class="sd">        tips3</span>
<span class="sd">            Positions of tips within chosen segment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores_tips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">allindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># logger.warning(f&quot;{len(segs)} segs iterating over.&quot;)</span>
        <span class="k">for</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segs</span><span class="p">):</span>
            <span class="c1"># logger.warning(f&quot;iseg = {iseg} begin iteration&quot;)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">segs_tips</span><span class="p">[</span><span class="n">iseg</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">segs_terminate_branching</span><span class="p">[</span><span class="n">iseg</span><span class="p">]):</span> <span class="c1"># do not consider too small segments???</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ending iterations short&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># restrict distance matrix to points in segment</span>
            <span class="n">Dseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">seg</span><span class="p">)]</span>

            <span class="n">third_maximizer</span> <span class="o">=</span> <span class="kc">None</span>
            
            <span class="k">if</span> <span class="n">segs_undecided</span><span class="p">[</span><span class="n">iseg</span><span class="p">]:</span>
                <span class="c1"># check that no tip connects with tip of another seg</span>
                <span class="k">for</span> <span class="n">jseg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">jseg</span> <span class="o">!=</span> <span class="n">iseg</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">itip</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span>
                                    <span class="n">segs_tips</span><span class="p">[</span><span class="n">jseg</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">segs_tips</span><span class="p">[</span><span class="n">iseg</span><span class="p">][</span><span class="n">itip</span><span class="p">]</span>
                                <span class="p">]</span>
                                <span class="o">&lt;</span> <span class="mf">0.5</span>
                                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span>
                                    <span class="n">segs_tips</span><span class="p">[</span><span class="n">iseg</span><span class="p">][</span><span class="o">~</span><span class="n">itip</span><span class="p">],</span> <span class="n">segs_tips</span><span class="p">[</span><span class="n">iseg</span><span class="p">][</span><span class="n">itip</span><span class="p">]</span>
                                <span class="p">]</span>
                            <span class="p">):</span>
                                <span class="c1"># logger.debug(</span>
                                <span class="c1">#     &#39;    group&#39;, iseg, &#39;with tip&#39;, segs_tips[iseg][itip],</span>
                                <span class="c1">#     &#39;connects with&#39;, jseg, &#39;with tip&#39;, segs_tips[jseg][1],</span>
                                <span class="c1"># )</span>
                                <span class="c1"># logger.debug(&#39;    do not use the tip for &quot;triangulation&quot;&#39;)</span>
                                <span class="n">third_maximizer</span> <span class="o">=</span> <span class="n">itip</span>
                                
            
            <span class="c1"># map the global position to the position within the segment</span>
            <span class="c1"># logger.warning(f&quot;iseg = {iseg}, tips = {segs_tips[iseg]}, seg = {seg}, &quot;)</span>
            <span class="n">tips</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">allindices</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">==</span> <span class="n">tip</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tip</span> <span class="ow">in</span> <span class="n">segs_tips</span><span class="p">[</span><span class="n">iseg</span><span class="p">]]</span> <span class="c1"># local index of tips in the seg</span>
            <span class="c1"># logger.warning(f&quot;iseg = {iseg} made it to line 658 and 660&quot;)</span>
            <span class="c1"># find the third point on the seg that has maximal added distance from the two tip points:</span>
            <span class="n">dseg</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dseg</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="n">third_tip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dseg</span><span class="p">)</span>

            <span class="c1"># logger.warning(f&quot;iseg = {iseg} made it to line 658 and 666&quot;)</span>
            <span class="k">if</span> <span class="n">third_maximizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># find a fourth point that has maximal distance to all three</span>
                <span class="n">dseg</span> <span class="o">+=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">third_tip</span><span class="p">]</span>
                <span class="n">fourth_tip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dseg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fourth_tip</span> <span class="o">!=</span> <span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">fourth_tip</span> <span class="o">!=</span> <span class="n">third_tip</span><span class="p">:</span>
                    <span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fourth_tip</span>
                    <span class="n">dseg</span> <span class="o">-=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dseg</span> <span class="o">-=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">third_tip</span><span class="p">]</span>
            <span class="n">tips3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tips</span><span class="p">,</span> <span class="n">third_tip</span><span class="p">)</span>

            <span class="c1"># logger.warning(f&quot;iseg = {iseg} made it to line 658 and 677&quot;)</span>

            <span class="c1"># compute the score as ratio of the added distance to the third tip,</span>
            <span class="c1"># to what it would be if it were on the straight line between the</span>
            <span class="c1"># two first tips, given by Dseg[tips[:2]]</span>
            <span class="c1"># if we did not normalize, there would be a danger of simply</span>
            <span class="c1"># assigning the highest score to the longest segment</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">dseg</span><span class="p">[</span><span class="n">tips3</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">/</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tips3</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># logger.warning(f&quot;iseg = {iseg}, SCORE = {score}&quot;)</span>
            <span class="c1"># score = (</span>
            <span class="c1">#     len(seg) if self.choose_largest_segment else score</span>
            <span class="c1"># )  # simply the number of points</span>
            <span class="n">score</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_largest_segment</span> <span class="k">else</span> <span class="n">score</span> <span class="c1"># simply the number of points</span>

            <span class="c1"># RE - following not needed because score automatically set to 0 if len(seg) &lt; min_branch_size (RE TODO: set threshold to check min_branch_size &gt; 2)</span>
            <span class="c1"># score = 0. if len(seg) &lt;= 1 else score # TODO: RE added - remove segs with 1 point (maybe also remove segs with &lt;= 2 points?)</span>
            <span class="c1"># score = 0. if np.isnan(score) else score # TODO: RE added - in case ratio of (d(0,x) + d(x, 1)) / d(0,1) is np.nan?</span>
            
            <span class="c1"># logger.warning(f&quot;iseg = {iseg}, SCORE2 = {score}&quot;)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;    group </span><span class="si">{</span><span class="n">iseg</span><span class="si">}</span><span class="s1"> score </span><span class="si">{</span><span class="n">score</span><span class="si">}</span><span class="s1"> n_points </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span><span class="si">}</span><span class="s1"> &#39;</span> <span class="o">+</span> <span class="s1">&#39;(too small)&#39;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_min_branch_size</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="c1"># len(seg) &lt; self.min_branch_size</span>
                <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="p">)</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_min_branch_size</span><span class="p">(</span><span class="n">seg</span><span class="p">):</span>  <span class="c1"># len(seg) &lt;= self.min_branch_size:</span>
                <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># logger.warning(f&quot;iseg = {iseg}, SCORE3 = {score}&quot;)</span>
            <span class="c1"># write result</span>
            <span class="n">scores_tips</span><span class="p">[</span><span class="n">iseg</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>
            <span class="n">scores_tips</span><span class="p">[</span><span class="n">iseg</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">tips3</span>
            <span class="c1"># logger.warning(f&quot;iseg = {iseg} end of iteration&quot;)</span>
            
        <span class="n">iseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">scores_tips</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">scores_tips</span><span class="p">[</span><span class="n">iseg</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">tips3</span> <span class="o">=</span> <span class="n">scores_tips</span><span class="p">[</span><span class="n">iseg</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">tips3</span>            </div>
        

<div class="viewcode-block" id="TDA.detect_branching"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA.detect_branching">[docs]</a>    <span class="k">def</span> <span class="nf">detect_branching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segs</span><span class="p">,</span> <span class="n">segs_tips</span><span class="p">,</span> <span class="n">segs_connects</span><span class="p">,</span> <span class="n">segs_undecided</span><span class="p">,</span>
                         <span class="n">segs_adjacency</span><span class="p">,</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">tips3</span><span class="p">,</span> <span class="n">segs_terminate_branching</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Detect branching on a given segment and update list parameters in place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segs</span>
<span class="sd">            Dchosen distance matrix restricted to segment.</span>
<span class="sd">        segs_tips</span>
<span class="sd">            Stores all tip points for the segments in segs.</span>
<span class="sd">        iseg</span>
<span class="sd">            Position of segment under study in segs.</span>
<span class="sd">        tips3</span>
<span class="sd">            The three tip points. They form a &#39;triangle&#39; that contains the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span>
        <span class="n">Dseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">seg</span><span class="p">)]</span>
        <span class="c1"># logger.warning(f&quot;*seg = {seg}&quot;)</span>

        <span class="c1"># given the three tip points and the distance matrix detect the</span>
        <span class="c1"># branching on the segment, return the list ssegs of segments that</span>
        <span class="c1"># are defined by splitting this segment</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_branch</span><span class="p">(</span><span class="n">Dseg</span><span class="p">,</span> <span class="n">tips3</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span>        
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># RE ADDED THIS CONDITION</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No unique branch detected - removed from consideration.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ssegs</span><span class="p">,</span> <span class="n">ssegs_tips</span><span class="p">,</span> <span class="n">ssegs_adjacency</span><span class="p">,</span> <span class="n">ssegs_connects</span><span class="p">,</span> <span class="n">trunk</span> <span class="o">=</span> <span class="n">result</span>

            <span class="c1"># map back to global indices</span>
            <span class="k">for</span> <span class="n">iseg_new</span><span class="p">,</span> <span class="n">seg_new</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs</span><span class="p">):</span>
                <span class="n">ssegs</span><span class="p">[</span><span class="n">iseg_new</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="n">seg_new</span><span class="p">]</span>
                <span class="n">ssegs_tips</span><span class="p">[</span><span class="n">iseg_new</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="n">ssegs_tips</span><span class="p">[</span><span class="n">iseg_new</span><span class="p">]]</span>
                <span class="n">ssegs_connects</span><span class="p">[</span><span class="n">iseg_new</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">ssegs_connects</span><span class="p">[</span><span class="n">iseg_new</span><span class="p">]])</span>            

            <span class="c1"># remove previous segment</span>
            <span class="n">segs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">iseg</span><span class="p">)</span>
            <span class="n">segs_tips</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">iseg</span><span class="p">)</span>

            <span class="c1"># insert trunk/undecided_cells at same position</span>
            <span class="n">segs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">iseg</span><span class="p">,</span> <span class="n">ssegs</span><span class="p">[</span><span class="n">trunk</span><span class="p">])</span>
            <span class="n">segs_tips</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">iseg</span><span class="p">,</span> <span class="n">ssegs_tips</span><span class="p">[</span><span class="n">trunk</span><span class="p">])</span>

            <span class="c1"># append other segments</span>
            <span class="n">segs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">seg</span> <span class="k">for</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs</span><span class="p">)</span> <span class="k">if</span> <span class="n">iseg</span> <span class="o">!=</span> <span class="n">trunk</span><span class="p">]</span>
            <span class="n">segs_tips</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">seg_tips</span> <span class="k">for</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">seg_tips</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs_tips</span><span class="p">)</span> <span class="k">if</span> <span class="n">iseg</span> <span class="o">!=</span> <span class="n">trunk</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssegs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="c1"># insert undecided cells at same position</span>
                <span class="n">segs_undecided</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">iseg</span><span class="p">)</span>
                <span class="n">segs_undecided</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">iseg</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            

            <span class="c1"># QUESTION FROM HERE</span>
            <span class="c1"># correct edges in adjacency matrix</span>
            <span class="n">n_add</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssegs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># RE START MODIFIED</span>
            <span class="c1"># append seg reference for branching</span>
            <span class="n">segs_terminate_branching</span> <span class="o">+=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ssegs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="c1"># RE END MODIFIED</span>
            
            <span class="n">prev_connecting_segments</span> <span class="o">=</span> <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">==</span> <span class="s1">&#39;haghverdi16&#39;</span><span class="p">:</span>
                <span class="n">segs_adjacency</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">iseg</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_add</span><span class="p">)]</span>                
                <span class="n">segs_connects</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="n">seg_connects</span>
                    <span class="k">for</span> <span class="n">iiseg</span><span class="p">,</span> <span class="n">seg_connects</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs_connects</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">iiseg</span> <span class="o">!=</span> <span class="n">trunk</span>
                <span class="p">]</span>
                <span class="n">prev_connecting_points</span> <span class="o">=</span> <span class="n">segs_connects</span><span class="p">[</span>  <span class="c1"># noqa: F841  TODO Evaluate whether to assign the variable or not</span>
                    <span class="n">iseg</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">jseg_cnt</span><span class="p">,</span> <span class="n">jseg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prev_connecting_segments</span><span class="p">):</span>
                    <span class="n">iseg_cnt</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">iseg_new</span><span class="p">,</span> <span class="n">seg_new</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">iseg_new</span> <span class="o">!=</span> <span class="n">trunk</span><span class="p">:</span>
                            <span class="n">pos</span> <span class="o">=</span> <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">jseg</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">iseg</span><span class="p">)</span>
                            <span class="n">connection_to_iseg</span> <span class="o">=</span> <span class="n">segs_connects</span><span class="p">[</span><span class="n">jseg</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">connection_to_iseg</span> <span class="ow">in</span> <span class="n">seg_new</span><span class="p">:</span>
                                <span class="n">kseg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_add</span> <span class="o">+</span> <span class="n">iseg_cnt</span>
                                <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">jseg</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">kseg</span>
                                <span class="n">pos_2</span> <span class="o">=</span> <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">jseg</span><span class="p">)</span>
                                <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pos_2</span><span class="p">)</span>
                                <span class="n">idx</span> <span class="o">=</span> <span class="n">segs_connects</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pos_2</span><span class="p">)</span>
                                <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">kseg</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jseg</span><span class="p">)</span>
                                <span class="n">segs_connects</span><span class="p">[</span><span class="n">kseg</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                                <span class="k">break</span>
                            <span class="n">iseg_cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs_adjacency</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_add</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs_adjacency</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="n">segs_connects</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ssegs_connects</span><span class="p">[</span><span class="n">trunk</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">segs_adjacency</span> <span class="o">+=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_add</span><span class="p">)]</span>
                <span class="n">segs_connects</span> <span class="o">+=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_add</span><span class="p">)]</span>
                <span class="n">kseg_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">iseg</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_add</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">jseg</span> <span class="ow">in</span> <span class="n">prev_connecting_segments</span><span class="p">:</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">jseg</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">iseg</span><span class="p">)</span>
                    <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">closest_points_in_jseg</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">closest_points_in_kseg</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">kseg</span> <span class="ow">in</span> <span class="n">kseg_list</span><span class="p">:</span>
                        <span class="n">reference_point_in_k</span> <span class="o">=</span> <span class="n">segs_tips</span><span class="p">[</span><span class="n">kseg</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">closest_points_in_jseg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">segs</span><span class="p">[</span><span class="n">jseg</span><span class="p">][</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">reference_point_in_k</span><span class="p">,</span> <span class="n">segs</span><span class="p">[</span><span class="n">jseg</span><span class="p">]]</span>
                                <span class="p">)</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="c1"># do not use the tip in the large segment j, instead, use the closest point</span>
                        <span class="n">reference_point_in_j</span> <span class="o">=</span> <span class="n">closest_points_in_jseg</span><span class="p">[</span>
                            <span class="o">-</span><span class="mi">1</span>
                        <span class="p">]</span>  <span class="c1"># segs_tips[jseg][0]</span>
                        <span class="n">closest_points_in_kseg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">segs</span><span class="p">[</span><span class="n">kseg</span><span class="p">][</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">reference_point_in_j</span><span class="p">,</span> <span class="n">segs</span><span class="p">[</span><span class="n">kseg</span><span class="p">]]</span>
                                <span class="p">)</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span>
                                <span class="n">closest_points_in_jseg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">closest_points_in_kseg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="c1"># print(jseg, &#39;(&#39;, segs_tips[jseg][0], closest_points_in_jseg[-1], &#39;)&#39;,</span>
                        <span class="c1">#       kseg, &#39;(&#39;, segs_tips[kseg][0], closest_points_in_kseg[-1], &#39;) :&#39;, distances[-1])</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
                    <span class="n">kseg_min</span> <span class="o">=</span> <span class="n">kseg_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">jseg</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">kseg_min</span>
                    <span class="n">segs_connects</span><span class="p">[</span><span class="n">jseg</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">closest_points_in_kseg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">pos_2</span> <span class="o">=</span> <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">jseg</span><span class="p">)</span>
                    <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pos_2</span><span class="p">)</span>
                    <span class="n">segs_connects</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pos_2</span><span class="p">)</span>
                    <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">kseg_min</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jseg</span><span class="p">)</span>
                    <span class="n">segs_connects</span><span class="p">[</span><span class="n">kseg_min</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_points_in_jseg</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

                <span class="c1"># if we split two clusters, we need to check whether the new segments connect to any of the other</span>
                <span class="c1"># old segments</span>
                <span class="c1"># if not, we add a link between the new segments, if yes, we add two links to connect them at the</span>
                <span class="c1"># correct old segments</span>
                <span class="n">do_not_attach_kseg</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">kseg</span> <span class="ow">in</span> <span class="n">kseg_list</span><span class="p">:</span>
                    <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">closest_points_in_jseg</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">closest_points_in_kseg</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">jseg_list</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">jseg</span>
                        <span class="k">for</span> <span class="n">jseg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">jseg</span> <span class="o">!=</span> <span class="n">kseg</span> <span class="ow">and</span> <span class="n">jseg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prev_connecting_segments</span>
                    <span class="p">]</span>
                    <span class="k">for</span> <span class="n">jseg</span> <span class="ow">in</span> <span class="n">jseg_list</span><span class="p">:</span>
                        <span class="n">reference_point_in_k</span> <span class="o">=</span> <span class="n">segs_tips</span><span class="p">[</span><span class="n">kseg</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">closest_points_in_jseg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">segs</span><span class="p">[</span><span class="n">jseg</span><span class="p">][</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">reference_point_in_k</span><span class="p">,</span> <span class="n">segs</span><span class="p">[</span><span class="n">jseg</span><span class="p">]]</span>
                                <span class="p">)</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="c1"># do not use the tip in the large segment j, instead, use the closest point</span>
                        <span class="n">reference_point_in_j</span> <span class="o">=</span> <span class="n">closest_points_in_jseg</span><span class="p">[</span>
                            <span class="o">-</span><span class="mi">1</span>
                        <span class="p">]</span>  <span class="c1"># segs_tips[jseg][0]</span>
                        <span class="n">closest_points_in_kseg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">segs</span><span class="p">[</span><span class="n">kseg</span><span class="p">][</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">reference_point_in_j</span><span class="p">,</span> <span class="n">segs</span><span class="p">[</span><span class="n">kseg</span><span class="p">]]</span>
                                <span class="p">)</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span>
                                <span class="n">closest_points_in_jseg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">closest_points_in_kseg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
                    <span class="n">jseg_min</span> <span class="o">=</span> <span class="n">jseg_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">jseg_min</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kseg_list</span><span class="p">:</span>
                        <span class="n">segs_adjacency_sparse</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span>
                            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg_adjacency</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segs_adjacency</span><span class="p">):</span>
                            <span class="n">segs_adjacency_sparse</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">seg_adjacency</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">segs_adjacency_sparse</span><span class="p">)</span>
                        <span class="n">paths_all</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_dijkstra_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">kseg</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">jseg_min</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">paths_all</span><span class="p">:</span>
                            <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">jseg_min</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kseg</span><span class="p">)</span>
                            <span class="n">segs_connects</span><span class="p">[</span><span class="n">jseg_min</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_points_in_kseg</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                            <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">kseg</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jseg_min</span><span class="p">)</span>
                            <span class="n">segs_connects</span><span class="p">[</span><span class="n">kseg</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_points_in_jseg</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                            <span class="n">logg</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    attaching new segment </span><span class="si">{</span><span class="n">kseg</span><span class="si">}</span><span class="s1"> at </span><span class="si">{</span><span class="n">jseg_min</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                            <span class="c1"># if we split the cluster, we should not attach kseg</span>
                            <span class="n">do_not_attach_kseg</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s1">&#39;    cannot attach new segment </span><span class="si">{</span><span class="n">kseg</span><span class="si">}</span><span class="s1"> at </span><span class="si">{</span><span class="n">jseg_min</span><span class="si">}</span><span class="s1"> &#39;</span>
                                <span class="s1">&#39;(would produce cycle)&#39;</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="n">kseg</span> <span class="o">!=</span> <span class="n">kseg_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;        continue&#39;</span><span class="p">)</span>
                                <span class="k">continue</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;        do not add another link&#39;</span><span class="p">)</span>
                                <span class="k">break</span>

                    <span class="k">if</span> <span class="n">jseg_min</span> <span class="ow">in</span> <span class="n">kseg_list</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">do_not_attach_kseg</span><span class="p">:</span>
                        <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">jseg_min</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kseg</span><span class="p">)</span>
                        <span class="n">segs_connects</span><span class="p">[</span><span class="n">jseg_min</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_points_in_kseg</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                        <span class="n">segs_adjacency</span><span class="p">[</span><span class="n">kseg</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jseg_min</span><span class="p">)</span>
                        <span class="n">segs_connects</span><span class="p">[</span><span class="n">kseg</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_points_in_jseg</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                        <span class="k">break</span>

            <span class="n">segs_undecided</span> <span class="o">+=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_add</span><span class="p">)]</span>                </div>


<div class="viewcode-block" id="TDA._detect_branch"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA._detect_branch">[docs]</a>    <span class="k">def</span> <span class="nf">_detect_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                       <span class="n">tips</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                       <span class="n">seg_reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
                           <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                           <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                           <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                           <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                           <span class="nb">int</span><span class="p">,</span>
                       <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Detect branching on given segment.</span>

<span class="sd">        Call function __detect_branching three times for all three orderings of</span>
<span class="sd">        tips. Points that do not belong to the same segment in all three</span>
<span class="sd">        orderings are assigned to a fourth segment. The latter is, by Haghverdi</span>
<span class="sd">        et al. (2016) referred to as &#39;undecided cells&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Dseg</span>
<span class="sd">            Dchosen distance matrix restricted to segment.</span>
<span class="sd">        tips</span>
<span class="sd">            The three tip points. They form a &#39;triangle&#39; that contains the data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ssegs</span>
<span class="sd">            List of segments obtained from splitting the single segment defined</span>
<span class="sd">            via the first two tip cells.</span>
<span class="sd">        ssegs_tips</span>
<span class="sd">            List of tips of segments in ssegs.</span>
<span class="sd">        ssegs_adjacency : `list`</span>
<span class="sd">            List of lists of the same length as ssegs,</span>
<span class="sd">            where the i-th entry is a list with the index of the trunk, if the i-th segment is not the trunk.</span>
<span class="sd">            Otherwise, the i-th entry is a list with the indices of all other segments beside the trunk.</span>
<span class="sd">        ssegs_connects : `list`</span>
<span class="sd">            List of lists of the same length as ssegs,</span>
<span class="sd">            where the i-th entry is a list of the form [index of data point in the trunk closest to the root of the i-th segment],</span>
<span class="sd">            if the i-th segment is not the trunk. Otherwise, the i-th entry is a list of indices of the closest cell in each other (non-trunk) segment</span>
<span class="sd">            to the trunk root.</span>
<span class="sd">        trunk : `int` </span>
<span class="sd">            Index of segment in ssegs that is the trunk. When there are undecided points, the trunk is the seg of undecided points.</span>
<span class="sd">            If there are no undecided points and 3 segments in sseg (i.e. branching), then the trunk is the seg with the smallest distance to</span>
<span class="sd">            the other segments. If there are only two segments in sseg, the first segment is set as the trunk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">==</span> <span class="s1">&#39;haghverdi16&#39;</span><span class="p">:</span>
            <span class="n">ssegs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_branching_single_haghverdi16</span><span class="p">(</span><span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">)</span>  <span class="c1"># correlation</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">==</span> <span class="s1">&#39;wolf17_tri&#39;</span><span class="p">:</span>
            <span class="n">ssegs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_branching_single_wolf17_tri</span><span class="p">(</span><span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">)</span>  <span class="c1"># closer in distance to tip than other two tips</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">==</span> <span class="s1">&#39;wolf17_bi&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">flavor</span> <span class="o">==</span> <span class="s1">&#39;wolf17_bi_un&#39;</span><span class="p">:</span> 
            <span class="n">ssegs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_branching_single_wolf17_bi</span><span class="p">(</span><span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;`flavor` needs to be in {&quot;haghverdi16&quot;, &quot;wolf17_tri&quot;, &quot;wolf17_bi, &quot;wolf17_bi_un&quot;&quot;}.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># make sure that each data point has a unique association with a segment</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ssegs</span><span class="p">),</span> <span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs</span><span class="p">):</span>
            <span class="n">masks</span><span class="p">[</span><span class="n">iseg</span><span class="p">][</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>                
        <span class="n">nonunique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="c1"># RE START MODIFIED - uncomment to match how original paper defines unique</span>
        <span class="c1"># if len(ssegs) == 3:</span>
        <span class="c1">#     allbranches = np.sum(masks, axis=0) == len(ssegs)</span>
        <span class="c1">#     twobranches = np.sum(masks[1:, :], axis=0) == len(ssegs) - 1</span>
        <span class="c1">#     nonunique = allbranches | twobranches</span>
        <span class="c1"># else:</span>
        <span class="c1">#     nonunique = np.sum(masks, axis=0) &gt; 1</span>
        <span class="c1"># # RE END MODIFIED</span>
        <span class="n">ssegs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">):</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">nonunique</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># RE START MODIFIED  - IN EVENT THAT THE SEG HAD NO UNIQUE MEMBERS AND IS NOW EMPTY:</span>
            <span class="c1"># ssegs.append(np.arange(Dseg.shape[0], dtype=int)[mask])</span>

            <span class="n">newseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">newseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Unique segment is empty, removing from consideration and no branching performed.&quot;</span><span class="p">)</span>
                <span class="c1"># continue</span>
                <span class="k">return</span> <span class="kc">None</span>
            
            <span class="n">ssegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newseg</span><span class="p">)</span>
            <span class="c1"># RE END MODIFIED</span>

        <span class="c1"># compute new tips within new segments</span>
        <span class="n">ssegs_tips</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># logger.warning(f&quot;*ssegs = {ssegs}&quot;)</span>
        <span class="k">for</span> <span class="n">inewseg</span><span class="p">,</span> <span class="n">newseg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs</span><span class="p">):</span>
            <span class="c1"># RE MODIFIED START</span>
            <span class="c1"># if len(np.flatnonzero(newseg)) &lt;= 1:</span>
            <span class="c1">#     logger.warning(f&#39;detected group with only {len(np.flatnonzero(newseg))} data points&#39;)</span>
            <span class="c1"># secondtip = newseg[np.argmax(Dseg[tips[inewseg]][newseg])]</span>
            <span class="c1"># ssegs_tips.append([tips[inewseg], secondtip]) # RE: SHOULD BE CHANGED</span>

            <span class="c1"># logger.warning(f&quot;*inewseg = {inewseg}, newseg = {newseg}&quot;)</span>
            <span class="n">secondtip</span> <span class="o">=</span> <span class="n">newseg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="n">inewseg</span><span class="p">]][</span><span class="n">newseg</span><span class="p">])]</span>
            <span class="n">firsttip</span> <span class="o">=</span> <span class="n">tips</span><span class="p">[</span><span class="n">inewseg</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">newseg</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;detected group with only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">newseg</span><span class="p">))</span><span class="si">}</span><span class="s1"> data points&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">firsttip</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">newseg</span><span class="p">):</span>
                <span class="n">new_firsttip</span> <span class="o">=</span> <span class="n">newseg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="n">inewseg</span><span class="p">]][</span><span class="n">newseg</span><span class="p">])]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;tip is no longer in the unique branched sub-segment, update tip to its nearest point in the new segment: </span><span class="si">{</span><span class="n">firsttip</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">new_firsttip</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">firsttip</span> <span class="o">=</span> <span class="n">new_firsttip</span>
            
            <span class="n">ssegs_tips</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">firsttip</span><span class="p">,</span> <span class="n">secondtip</span><span class="p">])</span> <span class="c1"># RE: SHOULD BE CHANGED</span>
            <span class="c1"># RE MODIFIED END</span>
        <span class="n">undecided_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="n">nonunique</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">undecided_cells</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ssegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">undecided_cells</span><span class="p">)</span>
            <span class="c1"># establish the connecting points with the other segments</span>
            <span class="n">ssegs_connects</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]]</span>
            <span class="k">for</span> <span class="n">inewseg</span><span class="p">,</span> <span class="n">newseg_tips</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssegs_tips</span><span class="p">):</span>
                <span class="n">reference_point</span> <span class="o">=</span> <span class="n">newseg_tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># closest (undecided) cell to the new segment tip within undecided cells</span>
                <span class="n">closest_cell</span> <span class="o">=</span> <span class="n">undecided_cells</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">][</span><span class="n">undecided_cells</span><span class="p">])</span>
                <span class="p">]</span>
                <span class="n">ssegs_connects</span><span class="p">[</span><span class="n">inewseg</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_cell</span><span class="p">)</span>
                <span class="c1"># closest cell to the undecided cells within new segment</span>
                <span class="n">closest_cell</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="n">inewseg</span><span class="p">][</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">closest_cell</span><span class="p">][</span><span class="n">ssegs</span><span class="p">[</span><span class="n">inewseg</span><span class="p">]])</span>
                <span class="p">]</span>
                <span class="n">ssegs_connects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_cell</span><span class="p">)</span>

            <span class="c1"># also compute tips for the undecided cells</span>
            <span class="n">tip_0</span> <span class="o">=</span> <span class="n">undecided_cells</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">undecided_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">undecided_cells</span><span class="p">])</span>
            <span class="p">]</span>

            <span class="n">tip_1</span> <span class="o">=</span> <span class="n">undecided_cells</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">tip_0</span><span class="p">][</span><span class="n">undecided_cells</span><span class="p">])]</span>
            <span class="n">ssegs_tips</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tip_0</span><span class="p">,</span> <span class="n">tip_1</span><span class="p">])</span>
            <span class="n">ssegs_adjacency</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
            <span class="c1"># RE START MODIFIED</span>
            <span class="c1"># trunk = 3</span>
            <span class="n">trunk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssegs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># logger.warning(f&quot;trunk = {trunk}&quot;)</span>
            <span class="c1"># RE END MODIFIED</span>


        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssegs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">reference_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">reference_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs_tips</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">reference_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs_tips</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">reference_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs_tips</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">closest_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># this is another strategy than for the undecided_cells</span>
            <span class="c1"># here it&#39;s possible to use the more symmetric procedure</span>
            <span class="c1"># shouldn&#39;t make much of a difference</span>
            <span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="p">]</span>
            <span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="p">]</span>
            <span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
            <span class="p">]</span>
            <span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="p">]</span>
            <span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
            <span class="p">]</span>
            <span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="p">]</span>

            <span class="n">added_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">added_dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
            <span class="p">)</span>

            <span class="n">added_dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
            <span class="p">)</span>

            <span class="n">added_dist</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">closest_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="p">)</span>

            <span class="n">trunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">added_dist</span><span class="p">)</span>
            <span class="n">ssegs_adjacency</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">trunk</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">trunk</span> <span class="k">else</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">trunk</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="n">ssegs_connects</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">trunk</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">trunk</span>
                <span class="k">else</span> <span class="p">[</span><span class="n">closest_points</span><span class="p">[</span><span class="n">trunk</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">trunk</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">trunk</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ssegs_adjacency</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">reference_point_in_0</span> <span class="o">=</span> <span class="n">ssegs_tips</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">closest_point_in_1</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point_in_0</span><span class="p">][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="p">]</span>
            <span class="n">reference_point_in_1</span> <span class="o">=</span> <span class="n">closest_point_in_1</span>  <span class="c1"># ssegs_tips[1][0]</span>
            <span class="n">closest_point_in_0</span> <span class="o">=</span> <span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">reference_point_in_1</span><span class="p">][</span><span class="n">ssegs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="p">]</span>
            <span class="n">ssegs_connects</span> <span class="o">=</span> <span class="p">[[</span><span class="n">closest_point_in_1</span><span class="p">],</span> <span class="p">[</span><span class="n">closest_point_in_0</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">ssegs</span><span class="p">,</span> <span class="n">ssegs_tips</span><span class="p">,</span> <span class="n">ssegs_adjacency</span><span class="p">,</span> <span class="n">ssegs_connects</span><span class="p">,</span> <span class="n">trunk</span>            </div>

        
<div class="viewcode-block" id="TDA._detect_branching_single_haghverdi16"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA._detect_branching_single_haghverdi16">[docs]</a>    <span class="k">def</span> <span class="nf">_detect_branching_single_haghverdi16</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detect branching on given segment. &quot;&quot;&quot;</span>
        <span class="c1"># compute branchings using different starting points the first index of</span>
        <span class="c1"># tips is the starting point for the other two, the order does not</span>
        <span class="c1"># matter</span>
        <span class="n">ssegs</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="c1"># permutations of tip cells</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  <span class="c1"># start by computing distances from the first tip</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1">#             -&quot;-                       second tip</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1">#             -&quot;-                       third tip</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ps</span><span class="p">):</span>
            <span class="c1"># logger.warning(f&quot;*iterating p: i = {i}&quot;)</span>
            <span class="n">ssegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__detect_branching_haghverdi16</span><span class="p">(</span><span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">[</span><span class="n">p</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">ssegs</span></div>


<div class="viewcode-block" id="TDA._detect_branching_single_wolf17_tri"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA._detect_branching_single_wolf17_tri">[docs]</a>    <span class="k">def</span> <span class="nf">_detect_branching_single_wolf17_tri</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">):</span>
        <span class="c1"># all pairwise distances</span>
        <span class="n">dist_from_0</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">dist_from_1</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">dist_from_2</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">closer_to_0_than_to_1</span> <span class="o">=</span> <span class="n">dist_from_0</span> <span class="o">&lt;</span> <span class="n">dist_from_1</span>
        <span class="n">closer_to_0_than_to_2</span> <span class="o">=</span> <span class="n">dist_from_0</span> <span class="o">&lt;</span> <span class="n">dist_from_2</span>
        <span class="n">closer_to_1_than_to_2</span> <span class="o">=</span> <span class="n">dist_from_1</span> <span class="o">&lt;</span> <span class="n">dist_from_2</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">closer_to_0_than_to_1</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">closer_to_0_than_to_2</span>
        <span class="n">segment_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">closer_to_0_than_to_1</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">closer_to_1_than_to_2</span>
        <span class="n">segment_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">Dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">closer_to_0_than_to_2</span>
        <span class="n">masks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">closer_to_1_than_to_2</span>
        <span class="n">segment_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">ssegs</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment_0</span><span class="p">,</span> <span class="n">segment_1</span><span class="p">,</span> <span class="n">segment_2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ssegs</span></div>


<div class="viewcode-block" id="TDA._detect_branching_single_wolf17_bi"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA._detect_branching_single_wolf17_bi">[docs]</a>    <span class="k">def</span> <span class="nf">_detect_branching_single_wolf17_bi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">,</span> <span class="n">tips</span><span class="p">):</span>
        <span class="n">dist_from_0</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">dist_from_1</span> <span class="o">=</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">closer_to_0_than_to_1</span> <span class="o">=</span> <span class="n">dist_from_0</span> <span class="o">&lt;</span> <span class="n">dist_from_1</span>
        <span class="n">ssegs</span> <span class="o">=</span> <span class="p">[</span><span class="n">closer_to_0_than_to_1</span><span class="p">,</span> <span class="o">~</span><span class="n">closer_to_0_than_to_1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ssegs</span></div>
    

    <span class="k">def</span> <span class="nf">__detect_branching_haghverdi16</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dseg</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tips</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect branching on given segment.</span>

<span class="sd">        Compute point that maximizes kendall tau correlation of the sequences of</span>
<span class="sd">        distances to the second and the third tip, respectively, when &#39;moving</span>
<span class="sd">        away&#39; from the first tip: tips[0]. &#39;Moving away&#39; means moving in the</span>
<span class="sd">        direction of increasing distance from the first tip.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Dseg</span>
<span class="sd">            Dchosen distance matrix restricted to segment.</span>
<span class="sd">        tips</span>
<span class="sd">            The three tip points. They form a &#39;triangle&#39; that contains the data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Segments obtained from &quot;splitting away the first tip cell&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sort distance from first tip point</span>
        <span class="c1"># then the sequence of distances Dseg[tips[0]][idcs] increases</span>
        <span class="c1"># logger.warning(f&quot;*inside: Dseg = {Dseg}, tips = {tips}&quot;)</span>
        <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="c1"># logger.warning(f&quot;*inside now&quot;)</span>
        <span class="c1"># logger.warning(f&quot;*inside: idcs = {idcs}&quot;)</span>
        <span class="c1"># consider now the sequence of distances from the other</span>
        <span class="c1"># two tip points, which only increase when being close to `tips[0]`</span>
        <span class="c1"># where they become correlated</span>
        <span class="c1"># at the point where this happens, we define a branching point</span>
        <span class="c1"># logger.warning(f&quot;*tips = {tips}&quot;)</span>
        <span class="c1"># logger.warning(f&quot;*a = {Dseg[tips[1]][idcs]}&quot;)</span>
        <span class="c1"># logger.warning(f&quot;*b = {Dseg[tips[2]][idcs]}&quot;)</span>
        

        <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kendall_tau_split</span><span class="p">(</span>
                <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">idcs</span><span class="p">],</span>
                <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">idcs</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># if we were in euclidian space, the following should work</span>
            <span class="c1"># as well, but here, it doesn&#39;t because the scales in Dseg are</span>
            <span class="c1"># highly different, one would need to write the following equation</span>
            <span class="c1"># in terms of an ordering, such as exploited by the kendall</span>
            <span class="c1"># correlation method above</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">idcs</span><span class="p">]</span> <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">idcs</span><span class="p">]</span> <span class="o">+</span> <span class="n">Dseg</span><span class="p">[</span><span class="n">tips</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">idcs</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># init list to store new segments</span>
        <span class="c1"># NOTE: ssegs not used...</span>
        <span class="n">ssegs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># noqa: F841  # TODO Look into this</span>
        <span class="c1"># first new segment: all points until, but excluding the branching point</span>
        <span class="c1"># increasing the following slightly from imax is a more conservative choice</span>
        <span class="c1"># as the criterion based on normalized distances, which follows below,</span>
        <span class="c1"># is less stable</span>
        <span class="k">if</span> <span class="n">imax</span> <span class="o">&gt;</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">idcs</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;segment is more than 95\</span><span class="si">% c</span><span class="s1">orrelated.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">imax</span> <span class="o">&gt;</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">idcs</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_kendall_tau_shift</span><span class="p">:</span>            
            <span class="c1"># if &quot;everything&quot; is correlated (very large value of imax), a more</span>
            <span class="c1"># conservative choice amounts to reducing this</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;shifting branching point away from maximal kendall-tau &#39;</span>
                <span class="s1">&#39;correlation (suppress this with `allow_kendall_tau_shift=False`)&#39;</span>
            <span class="p">)</span>
            <span class="n">ibranch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.95</span> <span class="o">*</span> <span class="n">imax</span><span class="p">)</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># otherwise, a more conservative choice is the following</span>
            <span class="n">ibranch</span> <span class="o">=</span> <span class="n">imax</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">idcs</span><span class="p">[:</span><span class="n">ibranch</span><span class="p">]</span>


<div class="viewcode-block" id="TDA.kendall_tau_split"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA.kendall_tau_split">[docs]</a>    <span class="k">def</span> <span class="nf">kendall_tau_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>  <span class="n">min_length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return splitting index that maximizes correlation in the sequences.</span>

<span class="sd">        Compute difference in Kendall tau for all splitted sequences.</span>

<span class="sd">        For each splitting index i, compute the difference of the two</span>
<span class="sd">        correlation measures kendalltau(a[:i], b[:i]) and</span>
<span class="sd">        kendalltau(a[i:], b[i:]).</span>

<span class="sd">        Returns the splitting index that maximizes</span>
<span class="sd">            kendalltau(a[:i], b[:i]) - kendalltau(a[i:], b[i:])</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a, b : `numpy.ndarray`</span>
<span class="sd">            One dimensional sequences.</span>
<span class="sd">        min_length : `int`, (``min_length &gt; 0``)</span>
<span class="sd">            Minimum number of data points automatically included in branch.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        imax : `int`</span>
<span class="sd">            Splitting index according to above description.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;a and b need to have the same size&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;a and b need to be one-dimensional arrays&#39;</span><span class="p">)</span>

        <span class="c1"># logger.warning(f&quot;*a = {a}&quot;)</span>
        <span class="c1"># logger.warning(f&quot;*b = {b}&quot;)</span>
        <span class="c1"># logger.warning(f&quot;*a[:min_length] = {a[:min_length]}&quot;)</span>
        <span class="c1"># logger.warning(f&quot;*a[min_length:] = {a[min_length:]}&quot;)</span>
        <span class="c1"># logger.warning(f&quot;*b[:min_length] = {b[:min_length]}&quot;)</span>
        <span class="c1"># logger.warning(f&quot;*b[min_length:] = {b[min_length:]}&quot;)</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
        <span class="n">idx_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_length</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">min_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">corr_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">idx_range</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">pos_old</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="n">min_length</span><span class="p">],</span> <span class="n">b</span><span class="p">[:</span><span class="n">min_length</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">neg_old</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">min_length</span><span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="n">min_length</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># logger.warning(f&quot;*pos_old = {pos_old}&quot;)</span>
        <span class="c1"># logger.warning(f&quot;*neg_old = {neg_old}&quot;)</span>
        <span class="c1"># logger.warning(f&quot;*idx_range = {idx_range}&quot;)</span>
        <span class="c1"># logger.warning(f&quot;*corr_coeff = {corr_coeff}&quot;)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_range</span><span class="p">):</span>
            <span class="c1"># logger.warning(f&quot;*ii, i = {ii}, {i}&quot;)</span>
            <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># compute differences in concordance when adding a[i] and b[i]</span>
                <span class="c1"># to the first subsequence, and removing these elements from</span>
                <span class="c1"># the second subsequence</span>
                <span class="n">diff_pos</span><span class="p">,</span> <span class="n">diff_neg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kendall_tau_diff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">pos_old</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kendall_tau_add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">diff_pos</span><span class="p">,</span> <span class="n">pos_old</span><span class="p">)</span>
                <span class="n">neg</span> <span class="o">=</span> <span class="n">neg_old</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kendall_tau_subtract</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">diff_neg</span><span class="p">,</span> <span class="n">neg_old</span><span class="p">)</span>
                <span class="n">pos_old</span> <span class="o">=</span> <span class="n">pos</span>
                <span class="n">neg_old</span> <span class="o">=</span> <span class="n">neg</span>
            <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># computation using sp.stats.kendalltau, takes much longer!</span>
                <span class="c1"># just for debugging purposes</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">neg</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># the following is much slower than using sp.stats.kendalltau,</span>
                <span class="c1"># it is only good for debugging because it allows to compute the</span>
                <span class="c1"># tau-a version, which does not account for ties, whereas</span>
                <span class="c1"># sp.stats.kendalltau computes tau-b version, which accounts for</span>
                <span class="c1"># ties</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">use_ties</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">neg</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">use_ties</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">corr_coeff</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">neg</span>
            <span class="c1"># logger.warning(f&quot;*corr_coeff = {corr_coeff}, corr_coeff[{ii}] = {pos - neg}&quot;)</span>
        <span class="c1"># RE START MODIFIED</span>
        <span class="c1"># iimax = np.argmax(corr_coeff)</span>
        <span class="c1"># imax = min_length + iimax</span>
        <span class="c1"># corr_coeff_max = corr_coeff[iimax]</span>

        <span class="c1"># TODO: add smoothing to corr_coeff before selecting max index</span>
        <span class="k">if</span> <span class="n">corr_coeff</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iimax</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">corr_coeff_max</span> <span class="o">=</span> <span class="mf">0.</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_corr</span><span class="p">:</span>
                <span class="c1"># logger.msg(f&quot;corr before smoothing: {corr_coeff}&quot;)</span>
                <span class="c1"># logger.msg(f&quot;imax before smoothing: {np.argmax(corr_coeff)}&quot;)</span>
                <span class="n">corr_coeff</span> <span class="o">=</span> <span class="n">utl</span><span class="o">.</span><span class="n">gauss_conv</span><span class="p">(</span><span class="n">corr_coeff</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">smoothness</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>
                <span class="c1"># logger.msg(f&quot;corr after smoothing: {corr_coeff}&quot;)</span>
                <span class="c1"># logger.msg(f&quot;imax after smoothing: {np.argmax(corr_coeff)}&quot;)</span>

            <span class="n">iimax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">corr_coeff</span><span class="p">)</span>
            <span class="n">corr_coeff_max</span> <span class="o">=</span> <span class="n">corr_coeff</span><span class="p">[</span><span class="n">iimax</span><span class="p">]</span>                
            
        <span class="c1"># iimax = 0 if corr_coeff.size == 0 else np.argmax(corr_coeff)</span>
        <span class="n">imax</span> <span class="o">=</span> <span class="n">min_length</span> <span class="o">+</span> <span class="n">iimax</span>
        <span class="c1"># corr_coeff_max = 0. if corr_coeff.size == 0 else corr_coeff[iimax]</span>
        
        <span class="c1"># RE END MODIFIED</span>
        <span class="k">if</span> <span class="n">corr_coeff_max</span> <span class="o">&lt;</span> <span class="mf">0.3</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;    is root itself, never obtain significant correlation&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">imax</span></div>


<div class="viewcode-block" id="TDA._kendall_tau_add"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA._kendall_tau_add">[docs]</a>    <span class="k">def</span> <span class="nf">_kendall_tau_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">len_old</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">diff_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tau_old</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute Kendall tau delta.</span>

<span class="sd">        The new sequence has length len_old + 1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        len_old</span>
<span class="sd">            The length of the old sequence, used to compute tau_old.</span>
<span class="sd">        diff_pos</span>
<span class="sd">            Difference between concordant and non-concordant pairs.</span>
<span class="sd">        tau_old</span>
<span class="sd">            Kendall rank correlation of the old sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">len_old</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">diff_pos</span><span class="p">)</span> <span class="o">/</span> <span class="n">len_old</span> <span class="o">-</span> <span class="n">tau_old</span><span class="p">)</span></div>


<div class="viewcode-block" id="TDA._kendall_tau_subtract"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA._kendall_tau_subtract">[docs]</a>    <span class="k">def</span> <span class="nf">_kendall_tau_subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">len_old</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">diff_neg</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tau_old</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute Kendall tau delta.</span>

<span class="sd">        The new sequence has length len_old - 1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        len_old</span>
<span class="sd">            The length of the old sequence, used to compute tau_old.</span>
<span class="sd">        diff_neg</span>
<span class="sd">            Difference between concordant and non-concordant pairs.</span>
<span class="sd">        tau_old</span>
<span class="sd">            Kendall rank correlation of the old sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">len_old</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">diff_neg</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">len_old</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau_old</span><span class="p">)</span></div>


<div class="viewcode-block" id="TDA._kendall_tau_diff"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA._kendall_tau_diff">[docs]</a>    <span class="k">def</span> <span class="nf">_kendall_tau_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute difference in concordance of pairs in split sequences.</span>

<span class="sd">        Consider splitting a and b at index i.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a, b : `numpy.ndarray`</span>
<span class="sd">            One dimensional sequences.</span>
<span class="sd">        i : `int`</span>
<span class="sd">            Index for splitting ``a`` and ``b``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        diff_pos</span>
<span class="sd">            Difference between concordant pairs for both subsequences.</span>
<span class="sd">        diff_neg</span>
<span class="sd">            Difference between non-concordant pairs for both subsequences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute ordering relation of the single points a[i] and b[i]</span>
        <span class="c1"># with all previous points of the sequences a and b, respectively</span>
        <span class="n">a_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">a_pos</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">a_pos</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">b_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">b_pos</span><span class="p">[</span><span class="n">b</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">b_pos</span><span class="p">[</span><span class="n">b</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">diff_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a_pos</span><span class="p">,</span> <span class="n">b_pos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># compute ordering relation of the single points a[i] and b[i]</span>
        <span class="c1"># with all later points of the sequences</span>
        <span class="n">a_neg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">a_neg</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">a_neg</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">b_neg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">b_neg</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">b_neg</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">diff_neg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a_neg</span><span class="p">,</span> <span class="n">b_neg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">diff_pos</span><span class="p">,</span> <span class="n">diff_neg</span></div>


<div class="viewcode-block" id="TDA.postprocess_segments"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA.postprocess_segments">[docs]</a>    <span class="k">def</span> <span class="nf">postprocess_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Convert the format of the segment class members. &quot;&quot;&quot;</span>
        <span class="c1"># make segs an array, where the array is a list of (boolean) mask arrays, each of the same length as the number of data points,</span>
        <span class="c1"># it&#39;s easier to store as there is a hdf5 equivalent</span>
        <span class="k">for</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segs</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segs</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="c1"># convert to arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segs_tips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segs_tips</span><span class="p">)</span></div>
        <span class="c1"># now each seg in segs is a boolean vector of length (self.distances.shape[0]), where it&#39;s True if that point is in the segment</span>


<div class="viewcode-block" id="TDA.set_segs_names"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA.set_segs_names">[docs]</a>    <span class="k">def</span> <span class="nf">set_segs_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return a single array that stores integer segment labels. &quot;&quot;&quot;</span>
        <span class="c1"># RE START MODIFIED - otherwise points that aren&#39;t in any segment are not differentiated from first segment.</span>
        <span class="c1"># segs_names = np.zeros(self.distances.shape[0], dtype=np.int8)</span>
        <span class="n">segs_names</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="c1"># RE END MODIFIED</span>

        <span class="c1"># RE START MODIFIED - include -1 in unique names</span>
        <span class="c1"># self.segs_names_unique = []</span>
        <span class="c1"># for iseg, seg in enumerate(self.segs):</span>
        <span class="c1">#     segs_names[seg] = iseg</span>
        <span class="c1">#     self.segs_names_unique.append(iseg)</span>
        
        <span class="k">for</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segs</span><span class="p">):</span>
            <span class="n">segs_names</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="n">iseg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segs_names_unique</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">segs_names</span><span class="p">))</span>
        <span class="c1"># RE END MODIFIED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segs_names</span> <span class="o">=</span> <span class="n">segs_names</span></div>


<div class="viewcode-block" id="TDA.order_pseudotime"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA.order_pseudotime">[docs]</a>    <span class="k">def</span> <span class="nf">order_pseudotime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Define indices that reflect segment and pseudotime order.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Writes : </span>

<span class="sd">        - indices : np.ndarray</span>
<span class="sd">              Index array of shape n, which stores an ordering of the data points</span>
<span class="sd">              with respect to increasing segment index and increasing pseudotime.</span>
<span class="sd">        - changepoints : np.ndarray</span>
<span class="sd">              Index array of shape len(ssegs)-1, which stores the indices of</span>
<span class="sd">              points where the segment index changes, with respect to the ordering</span>
<span class="sd">              of indices.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># within segs_tips, order tips according to pseudotime</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">itips</span><span class="p">,</span> <span class="n">tips</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segs_tips</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span><span class="p">[</span><span class="n">tips</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">segs_tips</span><span class="p">[</span><span class="n">itips</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segs_tips</span><span class="p">[</span><span class="n">itips</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    group </span><span class="si">{</span><span class="n">itips</span><span class="si">}</span><span class="s2"> is very small&quot;</span><span class="p">)</span>

        <span class="c1"># sort indices according to segments</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segs_names</span><span class="p">)</span>
        <span class="n">segs_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segs_names</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

        <span class="c1"># find changepoints of segments</span>
        <span class="n">changepoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">segs_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pseudotime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">iseg</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segs</span><span class="p">):</span>
                <span class="c1"># only consider one segment, it&#39;s already ordered by segment</span>
                <span class="n">seg_sorted</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="c1"># consider the pseudotime on this segment and sort them</span>
                <span class="n">seg_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pseudotime</span><span class="p">[</span><span class="n">seg_sorted</span><span class="p">])</span>
                <span class="c1"># within the segment, order indices according to increasing pseudotime</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">seg_sorted</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">seg_sorted</span><span class="p">][</span><span class="n">seg_indices</span><span class="p">]</span>

        <span class="c1"># define class members</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span>  <span class="c1"># indices of data points in original position, sorted by seg and then pseudotime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changepoints</span> <span class="o">=</span> <span class="n">changepoints</span>  <span class="c1"># indices of first tip of all branches</span>

        <span class="n">ordering_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">ordering_id</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ordering</span> <span class="o">=</span> <span class="n">ordering_id</span> <span class="c1"># ordered location of each data point</span></div>


<div class="viewcode-block" id="TDA.ordered_segs"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA.ordered_segs">[docs]</a>    <span class="k">def</span> <span class="nf">ordered_segs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; returns List[array] of segments where the ``i-th`` entry has the sorted indices</span>
<span class="sd">        corresponding to the ``i-th`` branch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># determine branches</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">segs_names_unique</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">changepoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">changepoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">changepoints</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">x0</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">changepoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">changepoints</span>

        <span class="n">segs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x1</span> <span class="ow">in</span> <span class="n">changepoints</span><span class="p">:</span>
            <span class="n">segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">])</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x1</span>
        <span class="n">segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">x0</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">segs</span></div>


<div class="viewcode-block" id="TDA.construct_topology"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA.construct_topology">[docs]</a>    <span class="k">def</span> <span class="nf">construct_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; construct connections between data points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G : `networkx.Graph`</span>
<span class="sd">            Graph where each node is a data point and edges reflect connections between them.</span>
<span class="sd">            Edges have attributes {&#39;connection&#39; : (str) &#39;intra-branch&#39; or &#39;inter-branch&#39;}</span>
<span class="sd">            Nodes have attributes</span>

<span class="sd">            .. code-block:: py</span>

<span class="sd">               {&#39;branch&#39; : (int) -1, 0, 1, ... where -1 indicates the data point was not identified with a branch,</span>
<span class="sd">                                   &#39;undecided&#39; : (bool) True if the data point is part of a trunk and False otherwise,</span>
<span class="sd">                                   &#39;name&#39; : (str) Original label if given data was a dataframe, otherwise the same as the node id}</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

        <span class="n">segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordered_segs</span><span class="p">()</span>

        <span class="c1"># add missing data points:</span>
        <span class="n">missing_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">segs</span><span class="p">))</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">missing_nodes</span><span class="p">),</span> <span class="n">branch</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">missing_nodes</span><span class="p">},</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;undecided&#39;</span><span class="p">)</span>

        <span class="c1"># add edges within branch:</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segs</span><span class="p">):</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">connection</span><span class="o">=</span><span class="s1">&#39;intra-branch&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;branch&#39;</span><span class="p">:</span> <span class="n">ix</span><span class="p">,</span> <span class="s1">&#39;undecided&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">segs_undecided</span><span class="p">[</span><span class="n">ix</span><span class="p">]}</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">seg</span><span class="p">})</span>

        <span class="c1"># add edges connecting branches:</span>
        <span class="n">segs_connects_triu</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segs_connects</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">segs_connects_triu</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">inter_branch_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">segs_connects</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">segs_connects</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">])</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)]</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">inter_branch_edges</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="s1">&#39;inter-branch&#39;</span><span class="p">)</span>

        <span class="c1"># add node names:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keeper</span><span class="o">.</span><span class="n">num_observations</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">keeper</span><span class="o">.</span><span class="n">observation_labels</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div>

        
<div class="viewcode-block" id="TDA.branchings_segments"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA.branchings_segments">[docs]</a>    <span class="k">def</span> <span class="nf">branchings_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_branches</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Detect up to `n_branches` branches and partition the data into corresponding segments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_branches : `int`</span>
<span class="sd">            Number of branches to look for (``n_branches &gt; 0``).</span>
<span class="sd">         </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Writes :</span>
<span class="sd">        </span>
<span class="sd">        - segs : `numpy.ndarray`, (n_segments, n_data_points)</span>
<span class="sd">              Array where each row stores a mask array that defines a segment.</span>
<span class="sd">        - segs_tips : `numpy.ndarray`, (n_segments, 2)</span>
<span class="sd">              Array where each row stores the</span>
<span class="sd">              indices of the two tip points of each segment.</span>
<span class="sd">        - segs_names : `numpy.ndarray`, (n_data_points, )</span>
<span class="sd">              Array that stores an integer label</span>
<span class="sd">              for each segment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detect_branches</span><span class="p">(</span><span class="n">n_branches</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postprocess_segments</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_segs_names</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_pseudotime</span><span class="p">()</span></div>


<div class="viewcode-block" id="TDA._set_pseudotime"><a class="viewcode-back" href="../../../reference/generated/netflow.pose.organization.html#netflow.pose.organization.TDA._set_pseudotime">[docs]</a>    <span class="k">def</span> <span class="nf">_set_pseudotime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return pseudotime with respect to root point. &quot;&quot;&quot;</span>
        <span class="c1"># root = self.root if root is None else root</span>
        <span class="c1"># if root is None:</span>
        <span class="c1">#     msg = &quot;&#39;root&#39; must be specified in order to compute pseudo-ordering.&quot;</span>
        <span class="c1">#     raise AssertionError(msg)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudotime</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span></div></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">scanpy.tools._dpt.py</span>
<span class="sd">line 157: dpt.branchings_segments()</span>
<span class="sd">    line 237: self.detect_branchings()  # Detect all branchings up to `n_branchings`. (here, called self.detect_branches())</span>
<span class="sd">    line 238: self.postprocess_segments() # make segs an array, where the array is a list of (boolean) mask arrays, each of the same length as the number of data points</span>
<span class="sd">    line 239: self.set_segs_names()</span>
<span class="sd">    line 240: self.order_pseudotime() # Define indices that reflect segment and pseudotime order.</span>

<span class="sd">&quot;&quot;&quot;</span>
            
        
            


    

                



</pre></div>

                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="../../../building/index.html">Installation</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="../../../reference/index.html">API reference</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="../../../tutorial/index.html">Tutorials</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="../../../references.html">References</a></li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
       Copyright 2023-2023, The netflow community.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    <br/>
  </p>
</div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>